[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Analyse et modÃ©lisation dâ€™agroÃ©cosystÃ¨mes sur R",
    "section": "",
    "text": "PrÃ©face\nCe cours a pour objectif de former les Ã©tudiants graduÃ©s en gÃ©nie agroenvironnemental, gÃ©nie civil, gÃ©nie Ã©cologique, agronomie, biologie, foresterie et Ã©cologie en analyse et modÃ©lisation de systÃ¨mes vivants. Les sujets traitÃ©s sont lâ€™introduction au langage de programmation R, lâ€™analyse statistique descriptive, la visualisation, la modÃ©lisation infÃ©rentielle, prÃ©dictive et dÃ©terministe.\nCe manuel est basÃ© sur le cours Analyse et modÃ©lisation dâ€™agroÃ©cosystÃ¨mes de Essi Parent (voir licence au bas de la page). La version proposÃ©e ici tient compte des mises Ã  jour des diffÃ©rents outils prÃ©sentÃ©s dans le manuel original. Elle est construite au format Quarto par Charles Frenette-ValliÃ¨res et AndrÃ©s Felipe Silva DimatÃ©"
  },
  {
    "objectID": "index.html#table-des-matiÃ¨res",
    "href": "index.html#table-des-matiÃ¨res",
    "title": "Analyse et modÃ©lisation dâ€™agroÃ©cosystÃ¨mes sur R",
    "section": "Table des matiÃ¨res",
    "text": "Table des matiÃ¨res\n\nIntroduction\nLa science des donnÃ©es avec R\nOrganisation des donnÃ©es et opÃ©rations sur des tableaux\nVisualisation\nScience ouverte et reproductibilitÃ©\nIntroduction Ã  Python\nBiostatistiques\nIntroduction Ã  lâ€™analyse bayÃ©sienne en Ã©cologie\nRÃ©gression\nExplorer R\nAssociation, partitionnement et ordination\nDÃ©tection de valeurs aberrantes et imputation de donnÃ©es manquantes\nLes sÃ©ries temporelles\nIntroduction Ã  lâ€™autoapprentissage\nLes donnÃ©es gÃ©ospatiales\nModÃ©lisation de mÃ©canismes Ã©cologiques\n\n\nAnalyse et modÃ©lisation dâ€™agroÃ©cosystÃ¨mes de Essi Parent est mis Ã  disposition selon les termes de la licence Creative Commons Attribution - Pas dâ€™Utilisation Commerciale - Partage dans les MÃªmes Conditions 4.0 International\n\nFondÃ©(e) sur une Å“uvre Ã  https://github.com/essicolo/ecologie-mathematique-R/."
  },
  {
    "objectID": "01-intro.html#dÃ©finitions",
    "href": "01-intro.html#dÃ©finitions",
    "title": "1Â  Introduction",
    "section": "1.1 DÃ©finitions",
    "text": "1.1 DÃ©finitions\nLes mathÃ©matiques confÃ¨rent aux humains une capacitÃ© dâ€™abstraction suffisamment complexe pour leur permettre de toucher les Ã©toiles et les atomes, de comprendre le passÃ© et de prÃ©dire le futur, de toucher lâ€™infini et de goÃ»ter Ã  lâ€™Ã©ternitÃ©. Ã€ partir des maths, on a pu crÃ©er des outils de calcul qui permettent de projeter des images de lâ€™univers, bien au-delÃ  de la Voie lactÃ©e. Mais apprÃ©hender le vivant, tout prÃ¨s de nous, demeure une tÃ¢che complexe.\n\n\n\n\n\nFigureÂ 1.2: Domaines scientifiques de lâ€™Ã©cologie mathÃ©matique.\n\n\n\n\nLâ€™Ã©cologie mathÃ©matique couvre un large spectre de domaines (FigureÂ 1.2), mais peut Ãªtre divisÃ©e en deux branches: lâ€™Ã©cologie thÃ©orique et lâ€™Ã©cologie quantitative (Legendre et Legendre, 2012). Alors que lâ€™Ã©cologie thÃ©orique sâ€™intÃ©resse Ã  lâ€™expression mathÃ©matique des mÃ©canismes Ã©cologiques, lâ€™Ã©cologie quantitative, plus empirique, en Ã©tudie principalement les phÃ©nomÃ¨nes. La modÃ©lisation Ã©cologique vise Ã  prÃ©voir une situation selon des conditions donnÃ©es. Faisant partie Ã  la fois de lâ€™Ã©cologie thÃ©orique et de lâ€™Ã©cologie quantitative, elle superpose souvent des mÃ©canismes de lâ€™Ã©cologie thÃ©orique et des phÃ©nomÃ¨nes empiriques de lâ€™Ã©cologie quantitative. Lâ€™Ã©cologie numÃ©rique comprend la branche descriptive de lâ€™Ã©cologie quantitative, câ€™est-Ã -dire quâ€™elle sâ€™intÃ©resse Ã  Ã©valuer des effets Ã  partir de donnÃ©es empiriques. Lâ€™exploration des donnÃ©es dans le but dâ€™y dÃ©couvrir des structures passe souvent par des techniques multivariÃ©es comme la classification hiÃ©rarchique ou la rÃ©duction dâ€™axe (par exemple, lâ€™analyse en composantes principales), qui sont davantage heuristiques (dans notre cas, bioheuristique) que statistiques. Les tests dâ€™hypothÃ¨ses et lâ€™analyse des probabilitÃ©s, quant Ã  eux, relÃ¨vent de la biostatistique.\nLe gÃ©nie Ã©cologique, une discipline intimement liÃ©e Ã  lâ€™Ã©cologie mathÃ©matique, est vouÃ© Ã  lâ€™analyse, la modÃ©lisation, la conception et la construction de systÃ¨mes vivants dans le but de rÃ©soudre de maniÃ¨re efficace des problÃ¨mes liÃ©s Ã  lâ€™Ã©cologie et Ã  une panoplie de domaines qui lui sont raccordÃ©s. Lâ€™agriculture est lâ€™un de ces domaines. Câ€™est dâ€™emblÃ©e la discipline qui sera prisÃ©e dans ce manuel. NÃ©anmoins, les principes qui seront discutÃ©s sont transfÃ©rables Ã  lâ€™Ã©cologie gÃ©nÃ©rale."
  },
  {
    "objectID": "01-intro.html#Ã -qui-sadresse-ce-manuel",
    "href": "01-intro.html#Ã -qui-sadresse-ce-manuel",
    "title": "1Â  Introduction",
    "section": "1.2 Ã€ qui sâ€™adresse ce manuel?",
    "text": "1.2 Ã€ qui sâ€™adresse ce manuel?\nLe cours vise Ã  introduire des Ã©tudiant.e.s graduÃ©.e.s en agronomie, biologie, Ã©cologie, sols, gÃ©nie agroenvironnemental, gÃ©nie civil et gÃ©nie Ã©cologique Ã  lâ€™analyse et la modÃ©lisation dans leur domaine, tant pour les appuyer pour leurs travaux de recherche que pour leur fournir une trousse dâ€™outils Ã©mancipatrice pour leur cheminement professionnel. Plus spÃ©cifiquement, vous serez accompagnÃ© Ã  dÃ©couvrir diffÃ©rents outils numÃ©riques qui vous permettront dâ€™apprÃ©hender vos donnÃ©es, dâ€™en faire Ã©merger lâ€™information et de construire des modÃ¨les. Lâ€™objectif de ce cours nâ€™est pas de vous former en mathÃ©matiques, mais de vous aider Ã  les utiliser. En ce sens, câ€™est un cours de pilotage, pas un cours de mÃ©canique. Vous ferez tout de mÃªme un peu de mÃ©canique pour mieux comprendre les rÃ©actions de notre machine.\nBien que des connaissances en programmation et en statistiques aideront grandement les Ã©tudiant.e.s Ã  apprÃ©hender ce document, une littÃ©ratie informatique nâ€™est pas requise. Dans tous les cas, quiconque voudra tirer profit de ce manuel devra faire preuve dâ€™autonomie. Vous serez guidÃ©s vers des ressources et des rÃ©fÃ©rences, mais je vous suggÃ¨re vivement de dÃ©velopper votre propre bibliothÃ¨que adaptÃ©e Ã  vos besoins et Ã  votre maniÃ¨re de comprendre."
  },
  {
    "objectID": "01-intro.html#les-logiciels-libres",
    "href": "01-intro.html#les-logiciels-libres",
    "title": "1Â  Introduction",
    "section": "1.3 Les logiciels libres",
    "text": "1.3 Les logiciels libres\nTous les outils numÃ©riques qui sont proposÃ©s dans ce cours sont des logiciels libres:\n\nÂ« Logiciel libre Â» [free software] dÃ©signe des logiciels qui respectent la libertÃ© des utilisateurs. En gros, cela veut dire que les utilisateurs ont la libertÃ© dâ€™exÃ©cuter, copier, distribuer, Ã©tudier, modifier et amÃ©liorer ces logiciels. Ainsi, Â« logiciel libre Â» fait rÃ©fÃ©rence Ã  la libertÃ©, pas au prix1 (pour comprendre ce concept, vous devez penser Ã  Â« libertÃ© dâ€™expression Â», pas Ã  Â« entrÃ©e libre Â»). - Projet GNU\n\nDonc: codes sources ouverts, dÃ©veloppement souvent communautaire, gratuitÃ©. Plusieurs raisons Ã©thiques, principalement liÃ©es au contrÃ´le de lâ€™environnement virtuel par les utilisateurs et les communautÃ©s, peuvent justifier lâ€™utilisation de logiciels libres. Plusieurs raisons pratiques justifient aussi cette orientation. Les logiciels libres vous permettent de transporter vos outils avec vous, dâ€™une entreprise Ã  lâ€™autre, au bureau, ou Ã  la maison, et ce, sans vous soucier dâ€™acheter de coÃ»teuses licences.\nIl existe tout de mÃªme des risques liÃ©s aux possibles erreurs dans les codes des logiciels communautaires. Ces risques sont dâ€™ailleurs les mÃªmes que ceux liÃ©s aux logiciels propriÃ©taires. Pour les scientifiques, une erreur peut mener Ã  une Ã©tude retirÃ©e de la littÃ©rature et mÃªme, potentiellement, des politiques publiques mal avisÃ©es. Pour les ingÃ©nieurs, les consÃ©quences pourraient Ãªtre dramatiques. Mais retenez quâ€™en toute circonstance, comme professionnel.le, vous Ãªtes responsable des outils que vous utilisez: vous devez vous assurer de la bonne qualitÃ© dâ€™un logiciel, quâ€™il soit propriÃ©taire ou communautaire.\nAlors que la qualitÃ© des logiciels propriÃ©taires est gÃ©nÃ©ralement suivie par audits, celle des logiciels libres est plutÃ´t soumise Ã  la vigilance communautaire. Chaque approche a ses avantages et inconvÃ©nients, mais elles ne sont pas exclusives. Ainsi, les logiciels libres peuvent Ãªtre auditÃ©s Ã  lâ€™externe par quiconque dÃ©cide de le faire. DiffÃ©rentes entreprises, souvent concurrentes, participent tant Ã  cette vigilance quâ€™au dÃ©veloppement des logiciels libres: elles en sont mÃªme souvent les instigatrices (comme RStudio, Anaconda et Enthought).\nPar ailleurs, ce manuel est distribuÃ© librement sous licence Creative commons, selon les termes suivants.\n\nAnalyse et modÃ©lisation dâ€™agroÃ©cosystÃ¨mes de Essi Parent est mis Ã  disposition selon les termes de la licence Creative Commons Attribution - Pas dâ€™Utilisation Commerciale - Partage dans les MÃªmes Conditions 4.0 International\n\nFondÃ©(e) sur une Å“uvre Ã  https://github.com/essicolo/ecologie-mathematique-R/."
  },
  {
    "objectID": "01-intro.html#langage-de-programmation",
    "href": "01-intro.html#langage-de-programmation",
    "title": "1Â  Introduction",
    "section": "1.4 Langage de programmation",
    "text": "1.4 Langage de programmation\n\n1.4.1 R\nCe cours est basÃ© sur le langage R. En plus dâ€™Ãªtre libre, R est un langage de programmation dynamique largement utilisÃ© dans le monde universitaire, et dont lâ€™utilisation sâ€™Ã©tend de maniÃ¨re soutenue hors des tours dâ€™ivoire.\n\nR is also the name of a popular programming language used by a growing number of data analysts inside corporations and academia. It is becoming their lingua franca partly because data mining has entered a golden age, whether being used to set ad prices, find new drugs more quickly or fine-tune financial models. New York Times, janvier 2009\n\nSon dÃ©veloppement est supportÃ© par la R Foundation for Statistical Computing, basÃ©e Ã  lâ€™UniversitÃ© de Vienne. Ã‰galement, lâ€™Ã©quipe de RStudio contribue largement au dÃ©veloppement de modules gÃ©nÃ©riques. R est principalement utilisÃ© pour le calcul statistique, mais les rÃ©cents dÃ©veloppements le rendent un outil de choix pour tout ce qui entoure la science des donnÃ©es, de lâ€™interaction avec les bases de donnÃ©es au dÃ©ploiement dâ€™outils dâ€™intelligence artificielle en passant par la visualisation. Une fois implÃ©mentÃ© avec des modules de calcul scientifique spÃ©cialisÃ©s en biologie, en Ã©cologie et en agronomie (que nous couvrirons au long du cours), R devient un outil de calcul convivial, rapide et fiable.\n\n\n1.4.2 Pourquoi pas Python?\nLa premiÃ¨re mouture de ce cours se fondait sur le langage Python. Tout comme R, Python est un langage de programmation dynamique prisÃ© pour le calcul scientifique. Python est un langage gÃ©nÃ©rique apprÃ©ciÃ© pour sa polyvalence et sa simplicitÃ©. Python est utilisÃ© autant pour crÃ©er des logiciels ou des sites web que pour le calcul scientifique. Ainsi, Python peut Ãªtre utilisÃ© en interopÃ©rabilitÃ© avec une panoplie de logiciels libres, comme QGIS pour la cartographie et FreeCAD pour le dessin technique. Il est particuliÃ¨rement apprÃ©ciÃ© en ingÃ©nierie pour ses modules de calcul par Ã©lÃ©ments finis (e.g.Â FeNICS) et en bioinformatique pour ses outils liÃ©s au sÃ©quenÃ§age (scikit-bio), mais ses lacunes en analyse statistique, en particulier en statistiques multivariÃ©es mâ€™ont amenÃ© Ã  favoriser R.\nBien que leurs possibilitÃ©s se superposent largement, ce serait une erreur dâ€™aborder R et Python comme des langages rivaux. Les deux langages sâ€™expriment de maniÃ¨re similaire et sâ€™inspirent mutuellement: apprendre Ã  travailler avec lâ€™un revient Ã  apprendre lâ€™autre. Les spÃ©cialistes en calcul scientifique tendent Ã  apprendre Ã  travailler avec plus dâ€™un langage de programmation. Par ailleurs, il existe de plus en plus des moyens de travailler en R et en Python dans un mÃªme flux de travail. Lâ€™interface de calcul RStudio, que nous utiliserons pendant le cours, permet dâ€™inclure des blocs de code en Python.\nDans la version mise Ã  jour du manuel, une courte introduction facultative Ã  Python est proposÃ©e.\n\n\n1.4.3 Pourquoi pas Matlab?\nParce quâ€™on est en 2024.\n\n\n1.4.4 Etâ€¦ SAS?\nParce quâ€™on est Ã  lâ€™universitÃ©.\n\n\n1.4.5 Mais pourquoi pas ______ ?\nDâ€™autres langages, comme Julia, Scala, Javascript et mÃªme Ruby sont utilisÃ©s en calcul scientifique. Ils sont nÃ©anmoins moins garnis et moins documentÃ©s que R. Des langages de plus bas niveau, comme Fortran et C++, viennent souvent appuyer les fonctions des autres langages: ces langages sont plus ardus Ã  utiliser au jour le jour, mais leur rapiditÃ© de calcul est imbattable."
  },
  {
    "objectID": "01-intro.html#contenu-du-manuel",
    "href": "01-intro.html#contenu-du-manuel",
    "title": "1Â  Introduction",
    "section": "1.5 Contenu du manuel",
    "text": "1.5 Contenu du manuel\nJe favorise une approche intuitive aux dÃ©veloppements mathÃ©matiques. Nous aborderons lâ€™analyse et la modÃ©lisation infÃ©rentielle, prÃ©dictive et mÃ©canistique appliquÃ©e aux agroÃ©cosystÃ¨mes.\nChapitreÂ 2 - Introduction au langage de programmation R. Quâ€™est-ce que R? Comment lâ€™aborder? Quelles sont les fonctionnalitÃ©s de base et comment tirer profit de tout lâ€™Ã©cosystÃ¨me de programmation?\nChapitreÂ 3 - Organisation des donnÃ©es et opÃ©rations sur des tableaux. Les tableaux permettent dâ€™enchÃ¢sser lâ€™information dans un format prÃªt-Ã -porter pour R. Comment les importer, les exporter, les filtrer, et en faire des sommaires?\nChapitreÂ 4 - Visualisation. Comment prÃ©senter lâ€™information contenue dans un long tableau en un seul coup dâ€™oeil?\nChapitreÂ 5 - Le travail collaboratif, le suivi de version et la science ouverte. Ce chapitre offre une introduction Ã  lâ€™utilisation des outils de calcul collaboratif, ainsi quâ€™un aperÃ§u du systÃ¨me de suivi de version git et de son utilisation sur GitHub.\nChapitreÂ 6 - Introduction Ã  Python (section facultative). Une trÃ¨s brÃ¨ve introduction au langage de programmation Python. Ce contenu est externe au cours et est lÃ  pour vous fournir des rÃ©fÃ©rences si vous souhaitez explorer ce langage dans le futur.\nChapitreÂ 7 - Biostatistiques. Il est audacieux de ne consacrer quâ€™un seul chapitre sur ce vaste sujet. Nous irons Ã  lâ€™essentielâ€¦ pour vous donner les outils qui permettront dâ€™approfondir le sujet.\nChapitreÂ 8 - Biostatistiques bayÃ©siennes (section facultative). Une trÃ¨s brÃ¨ve introduction pour qui est intÃ©ressÃ© Ã  lâ€™analyse bayÃ©sienne.\nChapitreÂ 9 - RÃ©gression. Ã€ venir.\nChapitreÂ 10 - Explorer R. La science des donnÃ©es Ã©volue rapidement. Vous gagnerez Ã  vous tenir au courrant de son Ã©volution, et immanquablement vous vous buterez sur des opÃ©rations qui vous sembleront insolubles. Ce chapitre vous accompagnera Ã  rester Ã  jour sur le dÃ©veloppement de R, Ã  poser de bonnes questions et proposera des modules intÃ©ressants en Ã©cologie mathÃ©matique.\nChapitreÂ 11 - Association, partitionnement et ordination. Les Ã©cosystÃ¨mes diffÃ¨rent, mais en quoi sont-ils semblables, et en quoi dffÃ¨rent-ils? Ces questions importantes peuvent Ãªtre abordÃ©s par lâ€™Ã©cologie numÃ©rique, domaine dâ€™Ã©tude au sein duquel lâ€™association, le partitionnement et lâ€™ordination sont des outils prÃ©dominants.\nChapitreÂ 12 - DÃ©tection de valeurs aberrantes et imputation. Une donnÃ©e aberrante sortira du lot, pour une raison ou pour une autre. Comment les dÃ©tecter de maniÃ¨re systÃ©matique? Dâ€™autre part, que faire lorsquâ€™une donnÃ©e est manquante? Peut-on lâ€™imputer? Comment?\nChapitreÂ 13 - Les sÃ©ries temporelles. Les capteurs modernes permettent de gÃ©nÃ©rer des donnÃ©es en fonction du temps. Que ce soit des donnÃ©es mÃ©tÃ©orologiques enregistrÃ©es quotidiennement ou des donnÃ©es de teneur en eau enregistrÃ©es au 5 secondes, les donnÃ©es en fonction du temps forment un signal. Comment analyser ces signaux?\nChapitreÂ 14 - Lâ€™autoapprentissage. Les applications de lâ€™intelligence artificielle ne sont limitÃ©es que par votre imagination. Encore faut-il lâ€™utiliserâ€¦ intelligemment.\nChapitreÂ 15 - Les donnÃ©es spatiales. Ce chapitre porte sur lâ€™utilisation de R comme systÃ¨me dâ€™information gÃ©ographique de base. Nous utiliserons aussi lâ€™autoapprentissage et les modÃ¨les dÃ©terministes comme outils dâ€™interpolation spatial.\nChapitreÂ 16 - La modÃ©lisation mÃ©canistique (section facultative). Les modÃ¨les sont des maquettes simplifiÃ©es. Comment utiliser les Ã©quations diffÃ©rentielles ordinaires pour crÃ©er ces maquettes?\nSi les chapitres 3 Ã  5 peuvent Ãªtre considÃ©rÃ©s comme fondamentaux pour bien maÃ®triser R, les autres peuvent Ãªtre feuilletÃ©s Ã  la piÃ¨ce, bien quâ€™ils forment une suite logique.\nChaque chapitre de ce manuel est rÃ©digÃ© en format Quarto, dans un environnement RStudio. Pour exÃ©cuter les commandes, vous pourrez soit les copier-coller dans R (ou RStudio), soit tÃ©lÃ©charger les fichiers-sources et exÃ©cuter les blocs de code.\nLe manuel original Ã©tait rÃ©digÃ© au format R Markdown et est toujours disponible Ã  lâ€™adresse suivante."
  },
  {
    "objectID": "01-intro.html#objectifs-gÃ©nÃ©raux",
    "href": "01-intro.html#objectifs-gÃ©nÃ©raux",
    "title": "1Â  Introduction",
    "section": "1.6 Objectifs gÃ©nÃ©raux",
    "text": "1.6 Objectifs gÃ©nÃ©raux\nÃ€ la fin du cours, vous serez en mesure:\n\nde programmer en langage R\ndâ€™importer, de manipuler (sÃ©lection des colonnes, filtres, sommaires statistiques) et dâ€™exporter des tableaux\nde gÃ©nÃ©rer des graphiques dâ€™utilisation commune\nde vous assurer que vos calculs soient auditables et reproductibles dans une perspective de science ouverte\ndâ€™apprÃ©hender des donnÃ©es Ã©cologiques et agronomiques Ã  lâ€™aide de tests statistiques frÃ©quentiels\ndâ€™explorer par vous-mÃªme les possibilitÃ©s offertes par la communautÃ© de dÃ©veloppement de modules R\ndâ€™explorer les donnÃ©es Ã  lâ€™aide des outils de lâ€™Ã©cologie numÃ©rique (association, partitionnement et ordination)\ndâ€™imputer des donnÃ©es manquantes dans un tableau et de dÃ©tecter des valeurs aberrantes\nde crÃ©er un modÃ¨le dâ€™autoapprentissage\ndâ€™effectuer une analyse de sÃ©rie temporelle\ndâ€™interpoler des donnÃ©es spatiales\nde modÃ©liser des Ã©quations diffÃ©rentielles ordinaires"
  },
  {
    "objectID": "01-intro.html#lectures-complÃ©mentaires",
    "href": "01-intro.html#lectures-complÃ©mentaires",
    "title": "1Â  Introduction",
    "section": "1.7 Lectures complÃ©mentaires",
    "text": "1.7 Lectures complÃ©mentaires\n\n1.7.1 Ã‰cologie mathÃ©matique\n\nHow to be a quantitative ecologist. Jason Mathipoulos vous prend par la main pour dÃ©couvrir les notions de mathÃ©matiques fondamentales en Ã©cologie, appliquÃ©es avec le langage R.\n\nNumerical ecology. Lâ€™ouvrage hautement dÃ©taillÃ© des frÃ¨res Legendre est non seulement fondamental, mais aussi fondateur dâ€™une science qui Ã©volue encore aujourdâ€™hui: lâ€™analyse des donnÃ©es Ã©cologiques.\nA practical guide to ecological modelling. Soetaert et Herman portent une attention particuliÃ¨re Ã  la prÃ©sentation des principes de modÃ©lisation dans un langage accessible - ce qui est rarement le cas dans le domaine de la modÃ©lisation. Les modÃ¨les prÃ©sentÃ©s concernent principalement les bilans de masse, en termes de systÃ¨mes de rÃ©actions chimiques et de relations biologiques.\nModÃ©lisation mathÃ©matique en Ã©cologie. Rare livre en modÃ©lisation Ã©cologique publiÃ© en franÃ§ais, la premiÃ¨re partie sâ€™attarde aux concepts mathÃ©matiques, alors que la deuxiÃ¨me planche Ã  les appliquer. Si le haut niveau dâ€™abstraction de la premiÃ¨re partie vous rebute, nâ€™hÃ©sitez pas dÃ©buter par la seconde partie et de vous rÃ©fÃ©rer Ã  la premiÃ¨re au besoin.\nA new ecology: systems perspective. Principalement grÃ¢ce au soleil, la Terre forme un ensemble de gradients dâ€™Ã©nergie qui se dÃ©clinent en des systÃ¨mes dâ€™une Ã©tonnante complexitÃ©. Câ€™est ainsi que le regrettÃ© Sven Erik JÃ¸rgensen (1934-2016, FigureÂ 1.3)) et ses collaborateurs dÃ©crivent les Ã©cosystÃ¨mes dans cet ouvrage qui fait suite aux travaux fondateurs de Howard Thomas Odum.\nEcological engineering. Principle and Practice.\nEcological processes handbook.\nModeling complex ecological dynamics\n\n\n\n\n\n\nFigureÂ 1.3: Sven Erik JÃ¸rgensen, Source: Elsevier.\n\n\n\n\n\n\n1.7.2 Programmation\n\nR for data science (2e). Lâ€™analyse de donnÃ©es est une branche importante de lâ€™Ã©cologie mathÃ©matique. Ce manuel traite des matrices et la manipulation de donnÃ©es chapitre 3), de la visualisation (chapitre 4) ainsi que de lâ€™apprentissage automatique (chapitre 14). R for data science (2e) repasse ces sujets plus en profondeur. En particulier, lâ€™ouvrage de Garrett Grolemund, Hadley Wickham et Mine Ã‡etinkaya-Rundel offre une introduction au module graphique ggplot2 et Ã  tidyverse.\nNumerical ecology with R. Daniel Borcard enseigne lâ€™Ã©cologie numÃ©rique Ã  lâ€™UniversitÃ© de MontrÃ©al. Son cours est condensÃ© dans ce livre recettes vouÃ© Ã  lâ€™application des principes lourdement dÃ©crits dans Numerical ecology.\n\n\n\n1.7.3 Divers\n\nThe truthful art. Dans cet ouvrage, Alberto Cairo sâ€™intÃ©resse Ã  lâ€™utilisation des donnÃ©es et de leurs prÃ©sentations pour fournir une information adÃ©quate Ã  diffÃ©rents publics."
  },
  {
    "objectID": "01-intro.html#besoin-daide",
    "href": "01-intro.html#besoin-daide",
    "title": "1Â  Introduction",
    "section": "1.8 Besoin dâ€™aide?",
    "text": "1.8 Besoin dâ€™aide?\nLes ouvrages de rÃ©fÃ©rence reconnus vous offrent des bases solides sur lesquelles vous pouvez vous appuyer dans vos travaux. Mais au-delÃ  des principes, au jour le jour, vous vous buterez immanquablement Ã  toutes sortes de petits problÃ¨mes. Quel module utiliser pour cette tÃ¢che prÃ©cise? Que veut dire ce message dâ€™erreur? Comment interprÃ©ter ce rÃ©sultat? Pour tous les petits accrocs du quotidien en calcul scientifique, internet offre de nombreuses ressources qui sont trÃ¨s hÃ©tÃ©rogÃ¨nes en qualitÃ©. Vous apprendrez Ã  reconnaÃ®tre les ressources fiables Ã  celles qui sont douteuses. Les plateformes basÃ©es sur Stack Exchange, comme Stack Overflow et Cross Validated, mâ€™ont souvent Ã©tÃ© dâ€™une aide prÃ©cieuse. Vous aurez avantage Ã  vous construire une petite banque dâ€™information avec un logiciel de prise de notes en collectant des liens, en prenant en notes certaines recettes et en suivant des sites dâ€™intÃ©rÃªt avec des flux RSS."
  },
  {
    "objectID": "01-intro.html#Ã -propos-de-lauteur",
    "href": "01-intro.html#Ã -propos-de-lauteur",
    "title": "1Â  Introduction",
    "section": "1.9 Ã€ propos de lâ€™auteur",
    "text": "1.9 Ã€ propos de lâ€™auteur\nJe mâ€™appelle Essi Parent. Je suis ingÃ©nieur Ã©cologue et professeur adjoint au DÃ©partement des sols et de gÃ©nie agroalimentaire de lâ€™UniversitÃ© Laval, QuÃ©bec, Canada. Je crois que la science est le meilleur moyen dâ€™apprÃ©hender le monde pour prendre des dÃ©cisions avisÃ©es."
  },
  {
    "objectID": "01-intro.html#un-cours-complÃ©mentaire-Ã -dautres-cours",
    "href": "01-intro.html#un-cours-complÃ©mentaire-Ã -dautres-cours",
    "title": "1Â  Introduction",
    "section": "1.10 Un cours complÃ©mentaire Ã  dâ€™autres cours",
    "text": "1.10 Un cours complÃ©mentaire Ã  dâ€™autres cours\nCe cours a Ã©tÃ© dÃ©veloppÃ© pour ouvrir des perspectives mathÃ©matiques en Ã©cologie et en agronomie Ã  la FSAA de lâ€™UniversitÃ© Laval. Il est complÃ©mentaire Ã  certains cours offerts dans dâ€™autres institutions acadÃ©miques au QuÃ©bec, dont ceux-ci.\n\nBIO2041. Biostatistiques 1, UniversitÃ© de MontrÃ©al\nBIO2042. Biostatistiques 2, UniversitÃ© de MontrÃ©al\nBIO109. Introduction Ã  la programmation scientifique, UniversitÃ© de Sherbrooke\nBIO500. MÃ©thodes en Ã©cologie computationnelle, UniversitÃ© de Sherbrooke."
  },
  {
    "objectID": "01-intro.html#contribuer-au-manuel",
    "href": "01-intro.html#contribuer-au-manuel",
    "title": "1Â  Introduction",
    "section": "1.11 Contribuer au manuel",
    "text": "1.11 Contribuer au manuel\nJe suis ouvert aux commentaires et suggestions. Pour contribuer directement, dirigez-vous sur le dÃ©pÃ´t du manuel sur GitHub, puis ouvrez une Issue pour en discuter. CrÃ©ez une nouvelle branche (fork), effectuez les modifications, puis lancer une requÃªte de fusion (pull request)."
  },
  {
    "objectID": "02-R.html#statistiques-ou-science-des-donnÃ©es",
    "href": "02-R.html#statistiques-ou-science-des-donnÃ©es",
    "title": "2Â  La science des donnÃ©es avec R",
    "section": "2.1 Statistiques ou science des donnÃ©es?",
    "text": "2.1 Statistiques ou science des donnÃ©es?\nSelon Whitlock et Schluter (2015), la statistique est lâ€™Ã©tude des mÃ©thodes pour dÃ©crire et mesurer des aspects de la nature Ã  partir dâ€™Ã©chantillon. Pour Grolemund et Wickham (2023), la science des donnÃ©es est une discipline excitante permettant de transformer des donnÃ©es brutes en comprÃ©hension, perspectives et connaissances. Oui, excitante! La diffÃ©rence entre les deux champs dâ€™expertise est subtile, et certaines personnes nâ€™y voient quâ€™une diffÃ©rence de ton.\n\n\nData Science is statistics on a Mac.\n\nâ€” Big Data Borat (@BigDataBorat) 27 aoÃ»t 2013\n\n\nConfinÃ©es Ã  ses applications traditionnelles, les statistiques sont davantage vouÃ©es Ã  la dÃ©finition de dispositifs expÃ©rimentaux et Ã  lâ€™exÃ©cution de tests dâ€™hypothÃ¨ses, alors que la science des donnÃ©es est moins linÃ©aire, en particulier dans sa phase dâ€™analyse, oÃ¹ de nouvelles questions (donc de nouvelles hypothÃ¨ses) peuvent Ãªtre posÃ©es au fur et Ã  mesure de lâ€™analyse. Cela arrive gÃ©nÃ©ralement davantage lorsque lâ€™on fait face Ã  de nombreuses observations sur lesquelles de nombreux paramÃ¨tres sont mesurÃ©s.\nLa quantitÃ© de donnÃ©es et de mesures auxquelles nous avons aujourdâ€™hui accÃ¨s grÃ¢ce aux technologies de mesure et de stockage relativement peu dispendieux rend la science des donnÃ©es une discipline particuliÃ¨rement attrayante, pour ne pas dire sexy."
  },
  {
    "objectID": "02-R.html#dÃ©buter-en-r",
    "href": "02-R.html#dÃ©buter-en-r",
    "title": "2Â  La science des donnÃ©es avec R",
    "section": "2.2 DÃ©buter en R",
    "text": "2.2 DÃ©buter en R\nR est un langage de programmation dÃ©rivÃ© du langage S, qui fut initialement lancÃ© en 1976.\n\n\n\n\n\nFigureÂ 2.2: Logo officiel du language R.\n\n\n\n\nR figure parmi les langages de programmation les plus utilisÃ©s au monde. Bien quâ€™il soit basÃ© sur les langages statiques C et Fortran, R est un langage dynamique, câ€™est-Ã -dire que le code peut Ãªtre exÃ©cutÃ© ligne par ligne ou bloc par bloc: un avantage majeur pour des activitÃ©s qui nÃ©cessitent des interactions frÃ©quentes. Bien que R soit surtout utilisÃ© pour le calcul statistique, il sâ€™impose de plus en plus comme outil privilÃ©giÃ© en sciences des donnÃ©es en raison des rÃ©cents dÃ©veloppements de modules dâ€™analyse, de modÃ©lisation et de visualisation, dont plusieurs seront utilisÃ©s dans ce manuel.\nUn langage de programmation sâ€™apprend un peu comme une langue. Au dÃ©but, un code R peut sembler incomprÃ©hensible. Et face Ã  son clavier, on ne sait pas trop comment exprimer ce que lâ€™on dÃ©sire. Au fur et Ã  mesure de lâ€™apprentissage, les symboles, les fonctions et le style deviennent de plus en plus familiers et on apprend tranquillement Ã  traduire en code ce que lâ€™on dÃ©sire effectuer. Comme une langue sâ€™apprend en la parlant dans la vie de tous les jours, un language de programmation sâ€™apprend avantageusement en solutionnant vos propres problÃ¨mes (FigureÂ 2.3).\n\n\n\n\n\nFigureÂ 2.3: R avant et maintenant, Illustration de Allison Horst"
  },
  {
    "objectID": "02-R.html#prÃ©parer-son-flux-de-travail",
    "href": "02-R.html#prÃ©parer-son-flux-de-travail",
    "title": "2Â  La science des donnÃ©es avec R",
    "section": "2.3 PrÃ©parer son flux de travail",
    "text": "2.3 PrÃ©parer son flux de travail\nIl existe de nombreuses maniÃ¨res dâ€™utiliser R. Parmi celles-ci, jâ€™en couvrirai 3:\n\nInstallation classique (installation suggÃ©rÃ©e)\nInstallation avec Anaconda\nUtilisation infonuagique\n\n\n2.3.1 Installation classique\nInstallation suggÃ©rÃ©e. Sur Windows ou Mac, dirigez-vous ici, tÃ©lÃ©chargez et installez. Sur Linux, ouvrez votre gestionnaire dâ€™application, chercher r-base (Ubuntu, Debian), R-base (openSuse) ou R-core (Fedora) et installez-le (assurez-vous que les librairies suivantes sont aussi installÃ©es: gcc, gcc-fortran, gcc-c++ et make), vous aurez peut-Ãªtre besoin dâ€™installer des librairies supplÃ©mentaires pour faire fonctionner certains modules.\n\nNote. Les modules prÃ©sentÃ©s dans ce cours devraient Ãªtre disponibles sur Linux, Windows et Mac. Ce nâ€™est pas le cas pour tous les modules R. La plupart fonctionnent nÃ©anmoins sur Linux, dont les systÃ¨mes dâ€™opÃ©ration (je recommande Ubuntu ou lâ€™une de ses dÃ©rivÃ©es comme elementary OS) sont de bonnes options pour le calcul scientifique.\n\nÃ€ cette Ã©tape, R devrait fonctionner dans un interprÃ©teur de commande . Si vous lancez R dans un terminal (chercher cmd dans le menu si vous Ãªtes sur Windows), vous obtiendrez quelque chose comme ceci.\n\n\n\n\n\nFigureÂ 2.4: R dans le terminal.\n\n\n\n\nLe symbole &gt; indique que R attend que vos instructions. Vous voilÃ  dans un Ã©tat mÃ©ditatif devant lâ€™indÃ©chiffrable vide du terminal ğŸ˜µ. Ne vous en faites pas: nous commencerons bientÃ´t Ã  jaser avec R.\nAvant cela, installons-nous au salon. Afin de travailler dans un environnement de travail plus confortable, je recommande lâ€™installation de lâ€™interface RStudio, gratuite et open source: tÃ©lÃ©chargez lâ€™installateur et suivez les instructions. RStudio ressemble Ã  ceci.\n\n\n\n\n\nFigureÂ 2.5: FenÃªtre de RStudio.\n\n\n\n\nEn haut Ã  droite se trouve un menu Project (None). Il sâ€™agit dâ€™un menu de vos projets. Je recommande dâ€™utiliser ces projets avec RStudio, qui vous permettront de mieux gÃ©rer vos sessions de travail, en particulier en lien avec les chemins vers vos donnÃ©es, graphiques, etc., que vous pouvez gÃ©rer relativement Ã  lâ€™emplacement de votre dossier de projet plutÃ´t quâ€™Ã  lâ€™emplacement des fichiers sur votre machine: nous verrons plus en dÃ©tails au chapitreÂ 5.\n\nEn haut Ã  gauche, vous avez vos feuilles de calcul, qui apparaÃ®tront en tant quâ€™onglets. Une feuille de calcul R script est une sÃ©rie de commandes que vous lancez en sÃ©quence. Il peut aussi sâ€™agir dâ€™un document Quarto si vous choisissez de travailler ainsi. Ce format vous permettra de dâ€™Ã©crire du texte en format Markdown entre des blocs de code. Il est question du format Quarto au chapitreÂ 5).\nEn bas Ã  gauche apparaÃ®t la Console, oÃ¹ vous voyez les commandes envoyÃ©es Ã  R ainsi que ses sorties.\nEn haut Ã  droite, les diffÃ©rents onglets indiquent oÃ¹ vous en Ãªtes dans vos calculs. En particulier, la liste sous Environment indique les objets qui ont Ã©tÃ© gÃ©nÃ©rÃ©s ou chargÃ©s jusquâ€™alors.\nEn bas Ã  droite, on retrouve des onglets de nature variÃ©s. Files contient les sous-dossiers et fichiers du dossier de projets. Plots est lâ€™endroit oÃ¹ apparaÃ®tront vos graphiques. Packages contient la liste des modules dÃ©jÃ  installÃ©s, ainsi quâ€™un outil de gestion des modules pour leur installation, leur dÃ©sinstallation et leur mise Ã  jour. Help affiche les fiches dâ€™aide des fonctions (pour obtenir de lâ€™aide sur une fonction dans RStudio, surlignez la fonction dans votre feuille de calcul, puis appuyez sur F1). Enfin, lâ€™onglet Viewer affichera les sorties HTML, en particulier les graphiques interactifs que vous gÃ©nÃ©rerez par exemple avec le module plotly, ou alors le rendu de votre fichier Quarto. Si votre environnement de travail Ã©tait un avion, R serait le moteur et RStudio serait le cockpit!\n\n\n\n\n\n\nFigureÂ 2.6: ScÃ¨ne de Fifi Brindacier (Astrid Lindgren, 1945).\n\n\n\n\n\n\n2.3.2 Installation avec Anaconda\nSi vous cherchez une trousse complÃ¨te dâ€™analyse de donnÃ©es, comprenant R et Python, vous pourrez prÃ©fÃ©rer Anaconda. Une fois installÃ©e, vous pourrez isoler un environnement de travail sur R, ou mÃªme isoler des environnements de travail particuliers pour vos projets. Une maniÃ¨re conviviale de crÃ©er des environnements de travail est de passer par lâ€™interface Anaconda navigator, que vous lancerez soit dans le menu Windows, soit en ligne de commande anaconda-navigator sous Mac et Linux, puis dâ€™installer r-essentials, rstudio et jupyterlab dans lâ€™onglet Environment. Vous pourrez aussi installer RStudio et Jupyter lab via lâ€™onglet Home de Anaconda navigator. Dans lâ€™environnement de base, installez le package nb_conda_kernels pour vous assurer que tous les noyaux (R, Python, etc.) installÃ©s dans les environnements de travail soient automatiquement accessibles dans Jupyter. Si vous dÃ©sirez utiliser dans Jupyter la version de R installÃ©e avec lâ€™installation classique, rÃ©fÃ©rez-vous au guide prÃ©sentÃ© en extra au bas de la page.\n\n\n\n\n\nFigureÂ 2.7: Anaconda navigator.\n\n\n\n\nJupyter lab est une interface notebook semblable Ã  Quarto - les format Jupyter (*.ipynb) et Quarto (*.qmd) sont par ailleurs convertibles grÃ¢ce au module jupytext. Lâ€™utilisation de R en Anaconda nâ€™est pas tout Ã  fait au point, et pourrait poser problÃ¨me pour lâ€™installation de certains modules. Si vous optez pour cette option, prÃ©parez-vous Ã  avoir Ã  bidouiller un peu. Plusieurs prÃ©fÃ¨rent Jupyter Ã  RStudio (ce nâ€™est pas mon cas).\n\n\n2.3.3 Utilisation infonuagique\nPas besoin dâ€™avoir une machine super puissante pour travailler en R. Il existe une multitude de services infonuagiques (dans le cloud) vous permettant de lancer vos calculs sur des serveurs plutÃ´t que sur votre Chromebook ou votre vieux laptop dÃ©glinguÃ©. Certains services sont gratuits, et dâ€™autres souvent plus Ã©laborÃ©s sont payants. Vous pouvez utiliser gratuitement Azure Notebooks ou un tour de passe-passe pour faire fonctionner Google colab en R. Une option gratuite de CoCalc vient avec un agressant bandeau rouge vif qui disparait avec lâ€™option payante.\nÃ€ mon avis, le service Nextjournal est celui dâ€™entre tous qui possÃ¨de en ce moment les meilleures qualitÃ©s dans sa version gratuite. Vous pourrez y travailler en mode collaboratif, comme dans Google docs. En outre, vous pouvez lancer ces notes de cours en les important dans Nextjournal. Vous devrez toutefois dÃ©poser les donnÃ©es dans lâ€™interface, puis Ã  chaque session installer les modules spÃ©cialisÃ©s. Le service gratuit offre peu de puissance de calcul, mais pour effectuer les applications de base, Ã§a devrait Ãªtre suffisant. La vidÃ©o ci-dessous monter comment importer les notes de cours dans Nextjournal.\nVideo"
  },
  {
    "objectID": "02-R.html#premiers-pas-avec-r",
    "href": "02-R.html#premiers-pas-avec-r",
    "title": "2Â  La science des donnÃ©es avec R",
    "section": "2.4 Premiers pas avec R",
    "text": "2.4 Premiers pas avec R\nR ne fonctionne pas avec des menus, en faisant danser une souris sous une musique de clics. Vous devrez donc entrer des commandes avec votre clavier, que vous apprendrez par cÅ“ur au fur et Ã  mesure, ou que vous retrouverez en lanÃ§ant des recherches sur internet. Par expÃ©rience personnelle, lorsque je travaille avec R, jâ€™ai toujours un navigateur ouvert prÃªt Ã  recevoir une question.\nLes Ã©tapes qui suivent sont des premiers pas. Elles ne feront pas de vous des ceintures noires de la programmation. La plupart des utilisateurs de R ont appris en se pratiquant sur leurs donnÃ©es, en se butant sur des obstacles, en apprenant comment les surmonter ou les contournerâ€¦\nPour lâ€™instant, ouvrez seulement un interprÃ©teur de commande, et lancez R. Voyons si R est aussi libre quâ€™on le prÃ©tend.\n\nâ€œLa libertÃ©, câ€™est la libertÃ© de dire que deux et deux font quatre. Si cela est accordÃ©, tout le reste suit.â€ - George Orwell, 1984\n\n\n2 + 2\n\n[1] 4\n\n\nEt voilÃ .\n\nLes opÃ©rations mathÃ©matiques sont effectuÃ©es telles que lâ€™on devrait sâ€™attendre.\n\n67.1 - 43.3\n\n[1] 23.8\n\n2 * 4\n\n[1] 8\n\n1 / 2\n\n[1] 0.5\n\n\nLâ€™exposant peut Ãªtre notÃ© ^, comme câ€™est le cas dans Excel, ou ** comme câ€™est le cas en Python.\n\n2^4\n\n[1] 16\n\n\n\n2**4\n\n[1] 16\n\n\n\n1 / 2 # utilisez des espaces de part et d'autre des opÃ©rateurs (sauf pour l'exposant) pour Ã©claircir le code\n\n[1] 0.5\n\n\nR ne lit pas ce qui suit le caractÃ¨re #. Cela vous laisse lâ€™opportunitÃ© de commenter un code comprenant une sÃ©quence de plusieurs lignes. Remarquez Ã©galement que la derniÃ¨re opÃ©ration comporte des espaces entre les nombres et lâ€™opÃ©rateur /. Dans ce cas (ce nâ€™est pas toujours le cas), les espaces ne signifient rien: ils aident seulement Ã  Ã©claircir le code. Il existe des guides pour lâ€™Ã©criture de code en R. Je recommande fortement de suivre mÃ©ticuleusement le guide de style de tidyverse.\nAssigner des objets Ã  des variables est fondamental en programmation. En R, on assigne traditionnellement avec la flÃ¨che &lt;-, mais vous verrez parfois le =, qui est davantage utilisÃ© comme standard dans dâ€™autres langages de programmation. Par exemple.\n\na &lt;- 3\n\nTruc. Essayez dâ€™inverser la flÃ¨che, e.g.Â 3 -&gt; a.\nTechniquement, a pointe vers le nombre entier 3. ConsÃ©quemment, on peut effectuer des opÃ©rations sur a.\n\na * 6\n\n[1] 18\n\n\n\nA + 2\n\nLe message dâ€™erreur nous dit que A nâ€™est pas dÃ©fini. Sa version minuscule, a, lâ€™est pourtant. La raison est que R considÃ¨re la case dans la dÃ©finition des objets. Utiliser la mauvaise case mÃ¨ne donc Ã  des erreurs.\nNote. Les messages dâ€™erreur ne sont pas toujours clairs, mais vous apprendrez Ã  les comprendre. Dans tous les cas, ils sont fait pour vous aider. Lisez-les attentivement!\nEn gÃ©nÃ©ral, le nom dâ€™une variable doit toujours commencer par une lettre, et ne doit pas contenir de caractÃ¨res rÃ©servÃ©s (espaces, +, *). Dans la dÃ©finition des variables, plusieurs utilisent des symboles . pour dÃ©limiter les mots, mais la barre de soulignement _ est Ã  prÃ©fÃ©rer. En effet, dans dâ€™autres langages de programmation comme Python, le . a une autre signification: son utilisation est Ã  Ã©viter autant que possible. De mÃªme, Ã©vitez lâ€™utilisation de majuscules pour nommer vos objets (voir le guide de style de tidyverse pour nommer les objets).\nNote. Ã€ ce stade, vous serez probablement plus Ã  lâ€™aise de copier-coller ces commandes dans votre terminal.\n\nrendement_arbre &lt;- 50 # pomme/arbre\nnombre_arbre &lt;- 300 # arbre\nnombre_pomme &lt;- rendement_arbre * nombre_arbre\nnombre_pomme\n\n[1] 15000\n\n\nComme chez la plupart des langages de programmation, R respecte les conventions des prioritÃ©s des opÃ©rations mathÃ©atiques.\n\n10 - 9^0.5 * 2\n\n[1] 4\n\n\n\n2.4.1 Types de donnÃ©es\nJusquâ€™Ã  maintenant, nous nâ€™avons utilisÃ© que des nombres entiers (integer ou int) et des nombres rÃ©els (numeric ou float64). R inclut dâ€™autres types. La chaÃ®ne de caractÃ¨re (string ou character) contient un ou plusieurs symboles. Elle est dÃ©finie entre des doubles guillemets \" \" ou des apostrophes ' '. Il nâ€™existe pas de standard sur lâ€™utilisation de lâ€™un ou de lâ€™autre, mais en rÃ¨gle gÃ©nÃ©rale, on utilise les apostrophes pour les expressions courtes, contenant un simple mot ou une sÃ©quence de lettres, et les guillemets pour les phrases. Une raison pour cela: les guillemets sont utiles pour insÃ©rer des apostrophes dans une chaÃ®ne de caractÃ¨re.\n\na &lt;- \"L'ours\"\nb &lt;- \"polaire\"\npaste(a, b)\n\n[1] \"L'ours polaire\"\n\n\nOn colle a et b avec la fonction paste. Notez que lâ€™objet a a Ã©tÃ© dÃ©fini prÃ©cÃ©demment. Il est possible en R de rÃ©assigner une variable, mais cela peut porter Ã  confusion, jusquâ€™Ã  gÃ©nÃ©rer des erreurs de calcul si une variable nâ€™est pas assignÃ©e Ã  lâ€™objet auquel on voulait rÃ©fÃ©rer.\nCombien de caractÃ¨res contient la chaÃ®ne \"L'ours polaire\"? R sait compter. Demandons-lui.\n\nc &lt;- paste(a, b)\nnchar(c)\n\n[1] 14\n\n\nQuatorze, câ€™est bien cela (comptez â€œLâ€™ours polaireâ€, en incluant lâ€™espace). Comme paste, nchar est une fonction incluse par dÃ©faut dans lâ€™environnement de travail de R: plus prÃ©cisÃ©ment, ces fonctions sont incluses dans le module base, inclut par dÃ©faut lorsque R est lancÃ©. La fonction est appelÃ©e en Ã©crivant nchar(). Mais une fonction de quoi? Des arguments, qui se trouvent entre les parenthÃ¨ses. Dans ce cas, il y a un seul argument: c.\nEn calcul scientifique, il est courant de lancer des requÃªtes dÃ©terminant si un rÃ©sultat est vrai ou faux.\n\na &lt;- 17\na &lt; 10\n\n[1] FALSE\n\na &gt; 10\n\n[1] TRUE\n\na == 10\n\n[1] FALSE\n\na != 10\n\n[1] TRUE\n\na == 17\n\n[1] TRUE\n\n!(a == 17)\n\n[1] FALSE\n\n\nJe viens dâ€™introduire un nouveau type de donnÃ©e: les donnÃ©es boolÃ©ennes (boolean, ou logical), qui ne peuvent prendre que deux Ã©tats - TRUE ou FALSE. En mÃªme temps, jâ€™ai utilisÃ© la fonction print parce que dans mon carnet, seule la derniÃ¨re opÃ©ration permet dâ€™afficher le rÃ©sultat. Si lâ€™on veut forcer une sortie, on utilise print. Puis, on a vu plus haut que le symbole = est rÃ©servÃ© pour assigner des objets: pour les tests dâ€™Ã©galitÃ©, on utilise le double Ã©gal, ==, ou != pour la non-Ã©galitÃ©. Enfin, pour inverser une donnÃ©e de type boolÃ©enne, on utilise le point dâ€™exclamation !.\n\n\n2.4.2 Les collections de donnÃ©es\nLes exercices prÃ©cÃ©dents ont permis de prÃ©senter les types de donnÃ©es offerts par dÃ©faut sur R qui sont les plus importants pour le calcul scientifique: int (integer, ou nombre entier), numeric (nombre rÃ©el), character (string, ou chaÃ®ne de caractÃ¨re) et logical (boolÃ©en). Dâ€™autres sâ€™ajouteront tout au long du cours, comme les catÃ©gories (factor) et les unitÃ©s de temps (date-heure).\nLorsque lâ€™on procÃ¨de Ã  des opÃ©rations de calcul en science, nous utilisons rarement des valeurs uniques. Nous prÃ©fÃ©rons les organiser et les traiter en collections. Par dÃ©faut, R offre quatre types importants de collections: les vecteurs, les matrices, les listes et les tableaux.\n\n2.4.2.1 Vecteurs\nDâ€™abord, les vecteurs sont une sÃ©rie de variables de mÃªme type. Un vecteur est dÃ©limitÃ© par la fonction c( ) (c pour concatÃ©nation). Les Ã©lÃ©ments de la liste sont sÃ©parÃ©s par des virgules.\n\nespece &lt;- c(\"Petromyzon marinus\", \"Lepisosteus osseus\", \"Amia calva\", \"Hiodon tergisus\")\nespece\n\n[1] \"Petromyzon marinus\" \"Lepisosteus osseus\" \"Amia calva\"        \n[4] \"Hiodon tergisus\"   \n\n\nPour accÃ©der aux Ã©lÃ©ments dâ€™une liste, one appelle la liste suivie de la position de lâ€™objet dÃ©sirÃ© entre crochets.\n\nespece[1]\n\n[1] \"Petromyzon marinus\"\n\nespece[2]\n\n[1] \"Lepisosteus osseus\"\n\nespece[1:3]\n\n[1] \"Petromyzon marinus\" \"Lepisosteus osseus\" \"Amia calva\"        \n\nespece[c(1, 3)]\n\n[1] \"Petromyzon marinus\" \"Amia calva\"        \n\n\nOn peut noter que le premier Ã©lÃ©ment de la liste est notÃ© 1, et non 0 comme câ€™est le cas de la plupart de langages. Le raccourcis 1:3 crÃ©e une liste de nombres entiers de 1 Ã  3 inclusivement, câ€™est-Ã -dire lâ€™Ã©quivalent de c(1, 2, 3). En effet, on crÃ©e une liste dâ€™indices pour soutirer des Ã©lÃ©ments dâ€™une liste. On peut utiliser le symbole de soustraction pour retirer un ou plusieurs Ã©lÃ©ments dâ€™un vecteur.\n\nespece[-c(1, 3)]\n\n[1] \"Lepisosteus osseus\" \"Hiodon tergisus\"   \n\n\nPour ajouter un Ã©lÃ©ment Ã  notre liste, on peut utiliser la fonction c( ).\n\nespece &lt;- c(espece, \"Cyprinus carpio\")\nespece\n\n[1] \"Petromyzon marinus\" \"Lepisosteus osseus\" \"Amia calva\"        \n[4] \"Hiodon tergisus\"    \"Cyprinus carpio\"   \n\n\nNotez que lâ€™on efface lâ€™objet espece par une concatÃ©nation de lâ€™objet espece, prÃ©cÃ©demment dÃ©finie, et dâ€™un autre Ã©lÃ©ment.\nEn lanÃ§ant espece[3] &lt;- \"Lepomis gibbosus\", il est possible de changer un Ã©lÃ©ment de la liste.\n\nespece[3] &lt;- \"Lepomis gibbosus\"\nespece\n\n[1] \"Petromyzon marinus\" \"Lepisosteus osseus\" \"Lepomis gibbosus\"  \n[4] \"Hiodon tergisus\"    \"Cyprinus carpio\"   \n\n\n\n\n2.4.2.2 Matrices\nUne matrice est un vecteur de dimension plus Ã©levÃ©e que 1. En Ã©cologie, on dÃ©passe rarement la deuxiÃ¨me dimension, quoi que les matrices en N dimensions soient courantes en modÃ©lisation mathÃ©matique. Je ne considÃ©rerai pour le moment que des matrices 2D. Comme câ€™est la cas des vecteurs, les matrices contiennent des valeurs de mÃªme type. En R, on peut attribuer aux matrices 2D des noms de ligne et de colonne.\n\nmat &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), \n              ncol = 3)\nmat\n\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n\n\n\ncolnames(mat) &lt;- c(\"A\", \"B\", \"C\")\nrownames(mat) &lt;- c(\"site_1\", \"site_2\", \"site_3\", \"site_4\")\nmat\n\n       A B  C\nsite_1 1 5  9\nsite_2 2 6 10\nsite_3 3 7 11\nsite_4 4 8 12\n\n\nOn peut soutirer les noms de colonne et les noms de ligne. Le rÃ©sultat est un vecteur.\n\ncolnames(mat)\n\n[1] \"A\" \"B\" \"C\"\n\nrownames(mat)\n\n[1] \"site_1\" \"site_2\" \"site_3\" \"site_4\"\n\n\n\n\n2.4.2.3 Listes\nLes listes sont des collections hÃ©tÃ©rogÃ¨nes dans lesquelles on peut placer les objets dÃ©sirÃ©s, sans distinction: elles peuvent mÃªme inclure dâ€™autres listes. Chacun des Ã©lÃ©ments de la liste peut Ãªtre identifiÃ© par une clÃ©.\n\nma_liste &lt;- list(\n  especes = c(\n    \"Petromyzon marinus\", \"Lepisosteus osseus\",\n    \"Amia calva\", \"Hiodon tergisus\"\n  ),\n  site = \"A101\",\n  stations_meteos = c(\"746583\", \"783786\", \"856363\")\n)\nma_liste\n\n$especes\n[1] \"Petromyzon marinus\" \"Lepisosteus osseus\" \"Amia calva\"        \n[4] \"Hiodon tergisus\"   \n\n$site\n[1] \"A101\"\n\n$stations_meteos\n[1] \"746583\" \"783786\" \"856363\"\n\n\nLes Ã©lÃ©ments de la liste peuvent Ãªtre soutirÃ©s par le nom de la clÃ© ou par lâ€™indice, de cette maniÃ¨re.\n\nma_liste$especes\n\n[1] \"Petromyzon marinus\" \"Lepisosteus osseus\" \"Amia calva\"        \n[4] \"Hiodon tergisus\"   \n\nma_liste[[1]]\n\n[1] \"Petromyzon marinus\" \"Lepisosteus osseus\" \"Amia calva\"        \n[4] \"Hiodon tergisus\"   \n\n\nExercice. AccÃ©der au deuxiÃ¨me Ã©lÃ©ment du vecteur dâ€™espÃ¨ces dans la liste ma_liste.\n\n\n2.4.2.4 Tableaux\nEnfin, le type de collection de donnÃ©es le plus important est le tableau, ou data.frame. Techniquement, il sâ€™agit dâ€™une liste composÃ©e de vecteurs de mÃªme longueur. Chaque colonne peut ainsi prendre un type de donnÃ©e indÃ©pendamment des autres colonnes.\n\ntableau &lt;- data.frame(\n  espece = c(\n    \"Petromyzon marinus\", \"Lepisosteus osseus\",\n    \"Amia calva\", \"Hiodon tergisus\"\n  ),\n  poids = c(10, 13, 21, 4),\n  longueur = c(35, 44, 50, 8)\n)\ntableau\n\n              espece poids longueur\n1 Petromyzon marinus    10       35\n2 Lepisosteus osseus    13       44\n3         Amia calva    21       50\n4    Hiodon tergisus     4        8\n\n\nEn programmation classique en R (nous verrons plus loin la mÃ©thode tidyverse), les Ã©lÃ©ments dâ€™un tableau se manipulent comme ceux dâ€™une matrice et les colonnes peuvent Ãªtre appelÃ©s comme les Ã©lÃ©ments dâ€™une liste.\n\ntableau[, 2:3]\n\n  poids longueur\n1    10       35\n2    13       44\n3    21       50\n4     4        8\n\ntableau$poids\n\n[1] 10 13 21  4\n\n\nVous verrez aussi, quoi que rarement, ce format, qui Ã  la diffÃ©rence du format $ gÃ©nÃ¨re un tableau.\n\ntableau[\"poids\"]\n\n  poids\n1    10\n2    13\n3    21\n4     4\n\n\nLe tableau est le format de collection Ã  privilÃ©gier pour manipuler des donnÃ©es. RÃ©cemment, le format de tableau tibble a Ã©tÃ© crÃ©Ã© par lâ€™Ã©quipe de RStudio pour offrir un format plus moderne.\n\n\n\n2.4.3 Les fonctions\nLorsque vous Ã©crivez une commande suivit de parenthÃ¨ses, comme data.frame(especes = ...), vous demandez Ã  R de passer Ã  lâ€™action en appelant une fonction. De maniÃ¨re trÃ¨s gÃ©nÃ©rale, une fonction transforme quelque chose en quelque chose dâ€™autre (FigureÂ 2.8).\n\n\n\n\n\nFigureÂ 2.8: SchÃ©ma simplifiÃ© dâ€™une fonction.\n\n\n\n\nPar exemple, la fonction mean() prend une collection de nombre comme entrÃ©e, puis en sort vous devinez quoi.\n\nmean(tableau$poids)\n\n[1] 12\n\n\nLes entrÃ©es sont appelÃ©s les arguments de la fonction. Leur dÃ©finition est toujours disponible dans la documentation.\nExercice. Familiarisez-vous avec la documentation de R en lanÃ§ant ?mean. Truc: si vous avez pris de lâ€™avance et que vous travaillez dÃ©jÃ  en RStudio, mettez le terme en surbrillance, puis appuyez sur F1.\nVous verrez dans la documentation que la fonction mean() demande trois arguments, x, trim et na.rm. Or nous avons seulement placÃ© un vecteur, sans spÃ©cifier dâ€™argument!\nEn effet. En lâ€™absence dâ€™une dÃ©finition des arguments, R supposera que les arguments dans la parenthÃ¨se, sÃ©parÃ©s par une virgule, sont prÃ©sentÃ©s dans le mÃªme ordre que celui spÃ©cifiÃ© dans la dÃ©finition de la fonction (celle qui est prÃ©sentÃ©e dans le fichier dâ€™aide). Dans le cas qui nous intÃ©resse, mean(tableau$poids) est Ã©quivalent Ã  mean(x = tableau$poids).\nMaintenant, selon la fiche dâ€™aide, lâ€™argument na.rm est un valeur logique spÃ©cifiant si oui (TRUE) ou non (FALSE) les valeurs manquantes doivent Ãªtre considÃ©rÃ©es (une moyenne dâ€™un vecteur comprenant au moins un NA sera de NA). En ne spÃ©cifiant rien, R prend la valeur par dÃ©faut, telle que spÃ©cifiÃ©e dans la documentation. Il en va de mÃªme pour lâ€™argument trim, qui permet dâ€™Ã©laguer des valeurs extrÃªmes. Dans la fiche dâ€™aide, mean(x, trim = 0, na.rm = FALSE, ...) signifie que par dÃ©faut, lâ€™argument x est vide (il doit donc Ãªtre spÃ©cifiÃ©), lâ€™argument trim est de 0 et lâ€™argument na.rm est FALSE.\n\nmean(c(6, 1, 7, 4, 9, NA, 1))\n\n[1] NA\n\nmean(c(6, 1, 7, 4, 9, NA, 1), na.rm = TRUE)\n\n[1] 4.666667\n\n\nVous nâ€™Ãªtes pas emprisonnÃ© par les fonctions offertes par R. Vous pouvez installer des modules qui complÃ¨tent les fonctions de base de R: on le verra un peu plus loin dans ce chapitre. Mais pour lâ€™instant, voyons comment vous pouvez crÃ©er vos propres fonctions. Disons que vous voulez crÃ©er une fonction qui calcule la sortie de \\(x^3-2y+a\\). Pour obtenir la rÃ©ponse, on a besoin des arguments x, y et a. La sortie de la fonction est ici triviale: la rÃ©ponse de lâ€™Ã©quation. Lâ€™opÃ©ration function permet de prendre Ã§a en charge.\n\noperation_f &lt;- function(x, y, a = 10) {\n  return(x^3 - 2 * y + a)\n}\n\nNotez que a a une valeur par dÃ©faut. La sortie de la fonction est ce qui se trouve entre les parenthÃ¨ses de return. Vous pouvez maintenant utiliser la fonction operation_f au besoin.\n\noperation_f(x = 2, y = 3, a = 1)\n\n[1] 3\n\n\nUne telle fonction est peu utile. Mais lâ€™utilisation de fonctions personnalisÃ©es vous permettra dâ€™Ã©viter de rÃ©pÃ©ter la mÃªme opÃ©ration plusieurs fois dans un flux de travail, en Ã©vitant de gÃ©nÃ©rer trop de code, donc aussi de potentielles erreurs. Personnellement, jâ€™utilise les fonctions surtout pour gÃ©nÃ©rer des graphiques personnalisÃ©s.\nExercice. Afin dâ€™acquÃ©rir de lâ€™autonomie, vous devrez Ãªtre en mesure de trouver le nom des commandes dont vous avez besoin pour effectuer la tÃ¢che que vous dÃ©sirez effectuer. Cela peut causer des frustrations, mais vous vous sentirez toujours plus Ã  lâ€™aise avec R jour aprÃ¨s jour. Lâ€™exercice ici est de trouver par vous-mÃªme la commande qui vous permettra mesurer la longueur dâ€™un vecteur.\n\n\n2.4.4 Les boucles\nLes boucles permettent dâ€™effectuer une mÃªme suite dâ€™opÃ©rations sur plusieurs objets. Pour faire suite Ã  notre exemple, nous dÃ©sirons obtenir le rÃ©sultat de lâ€™opÃ©ration f pour des paramÃ¨tres que nous enregistrons dans ce tableau.\n\nparams &lt;- data.frame(\n  x = c(2, 4, 1, 5, 6),\n  y = c(3, 4, 8, 1, 0),\n  a = c(6, 1, 8, 2, 5)\n)\nparams\n\n  x y a\n1 2 3 6\n2 4 4 1\n3 1 8 8\n4 5 1 2\n5 6 0 5\n\n\nNous crÃ©ons un vecteur vide, puis nous effectuons une itÃ©ration ligne par ligne en remplissant le vecteur.\n\noperation_res &lt;- c()\nfor (i in 1:nrow(params)) {\n  operation_res[i] &lt;- operation_f(x = params[i, 1], y = params[i, 2], a = params[i, 3])\n}\noperation_res\n\n[1]   8  57  -7 125 221\n\n\nEn faisant varier i sur des valeurs du vecteur donnÃ© par la sÃ©quence de nombres entiers de 1 au nombre de ligne du tableau de paramÃ¨tres, nous demandons Ã  R dâ€™effectuer la suite dâ€™opÃ©ration entre les accolades {}. Ã€ chaque boucle, i prend une valeur de la sÃ©quence. i est utilisÃ© ici comme indice de la ligne Ã  soutirer du tableau params, qui correspond Ã  lâ€™indice dans le vecteur operation_res.\nAinsi, chaque rÃ©sultat est calculÃ© dans lâ€™ordre des lignes du tableau de paramÃ¨tres et lâ€™on pourra trÃ¨s bien y coller nos rÃ©sultats:\n\nparams$resultats &lt;- operation_res\nparams\n\n  x y a resultats\n1 2 3 6         8\n2 4 4 1        57\n3 1 8 8        -7\n4 5 1 2       125\n5 6 0 5       221\n\n\nNotez que puisque la colonne resultat nâ€™existe pas dans le tableau params, R crÃ©e automatiquement une nouvelle colonne.\nLes boucles for vous permettront par exemple de gÃ©nÃ©rer en peu de temps 10, 100, 1000 graphiques (autant que vous voulez), chacun issu de simulations obtenues Ã  partir de conditions initiales diffÃ©rentes, et de les enregistrer dans un rÃ©pertoire sur votre ordinateur. Un travail qui pourrait prendre des semaines sur Excel peut Ãªtre effectuÃ© en R en quelques secondes.\nUn second outil est disponible pour les itÃ©rations: les boucles while. Elles effectuent une opÃ©ration tant quâ€™un critÃ¨re nâ€™est pas atteint. Elles sont utiles pour les opÃ©rations oÃ¹ lâ€™on cherche une convergence. Je les couvre rapidement puisquâ€™elles sont rarement utilisÃ©es dans les flux de travail courants. En voici un petit exemple.\n\nx &lt;- 100\nwhile (x &gt; 1.1) {\n  x &lt;- sqrt(x)\n  print(x)\n}\n\n[1] 10\n[1] 3.162278\n[1] 1.778279\n[1] 1.333521\n[1] 1.154782\n[1] 1.074608\n\n\nNous avons initiÃ© x Ã  une valeur de 100. Puis, tant que (while) le test x &gt; 1.1 est vrai, attribuer Ã  x la nouvelle valeur calculÃ©e en extrayant la racine de la valeur prÃ©cÃ©dente de x. Enfin, indiquer la valeur avec print.\n\n\n2.4.5 Conditions: if, else if, else\n\nSi la condition 1 est remplie, effectuer une suite dâ€™instructions 1. Si la condition 1 nâ€™est pas remplie, et si la condition 2 est remplie, effectuer la suite dâ€™instructions 2. Sinon, effectuer la suite dâ€™instruction 3.\n\nVoilÃ  comment on exprime une suite de conditions. Prenons lâ€™exemple simple dâ€™une discrÃ©tisation dâ€™une valeur continue. Si \\(x&lt;10\\), il est classÃ© comme faible. Si \\(10 \\leq x &lt;20\\), il est classÃ© comme moyen. Si \\(x \\geq 20\\), il est classÃ© comme Ã©levÃ©. PlaÃ§ons cette classification dans une fonction.\n\nclassification &lt;- function(x, lim1 = 10, lim2 = 20) {\n  if (x &lt; lim1) {\n    categorie &lt;- \"faible\"\n  } else if (x &lt; lim2) {\n    categorie &lt;- \"moyen\"\n  } else {\n    categorie &lt;- \"Ã©levÃ©\"\n  }\n  return(categorie)\n}\nclassification(-10)\n\n[1] \"faible\"\n\nclassification(15.4)\n\n[1] \"moyen\"\n\nclassification(1000)\n\n[1] \"Ã©levÃ©\"\n\n\nUne condition est dÃ©finie avec le if, suivi du test Ã  vrai ou faux entre parenthÃ¨ses. Si le test retourne un vrai (TRUE), lâ€™instruction entre accolades est exÃ©cutÃ©e. Si elle est fausse, on passe au suivant.\nExercice. Explorer les commandes ifelse et cut et rÃ©flÃ©chissez Ã  la maniÃ¨re quâ€™elles pourraient Ãªtre utilisÃ©es pour effectuer une discrÃ©tisation plus efficacement quâ€™avec les if et les else.\n\n\n2.4.6 Installer et charger un module\nLa plupart des opÃ©rations dâ€™ordre gÃ©nÃ©ral (comme les racines carrÃ©es, les tests statistiques, la gestion de matrices et de tableau, les graphiques, etc.) sont accessibles grÃ¢ce aux modules de base de R, qui sont installÃ©s et chargÃ©s par dÃ©faut lors du dÃ©marrage de R. Des Ã©quipes de travail ont nÃ©anmoins dÃ©veloppÃ© plusieurs modules pour rÃ©pondre Ã  leurs besoins spÃ©cialisÃ©s, et les ont laissÃ©s disponibles au grand public dans des modules que vous pouvez installer dâ€™un dÃ©pÃ´t CRAN (le AppStore de R), dâ€™un dÃ©pÃ´t Anaconda (le AppStore de Anaconda, si vous utilisez cette plate-forme), dâ€™un dÃ©pÃ´t Github (dÃ©pÃ´ts dÃ©centralisÃ©s), etc.\nRStudio possÃ¨de un pratique bouton Install qui vous permet dâ€™y inscrire une liste de modules. Le navigateur anaconda offre aussi une interface dâ€™installation. La commande R pour installer un module est install.packages(\"ggplot2\"), si par exemple vous dÃ©sirez installer ggplot2, le module graphique par excellence en R. Câ€™est la commande que RStudio lancera tout seul si vous lui demandez dâ€™installer ggplot2.\nLes modules sont lâ€™Ã©quivalent des applications spÃ©cialisÃ©es que vous installez sur un tÃ©lÃ©phone mobile. Pour les utiliser, il faut les ouvrir.\nGÃ©nÃ©ralement, jâ€™ouvre toutes les applications nÃ©cessaires Ã  mon flux de travail au tout dÃ©but de ma feuille de calcul (la prochaine cellule retournera un message dâ€™erreur si les packages ne sont pas installÃ©s).\n\nlibrary(\"tidyverse\") # mÃ©ta-package qui charge entre autres dplyr et ggplot2\n\nâ”€â”€ Attaching core tidyverse packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 2.0.0 â”€â”€\nâœ” dplyr     1.1.3     âœ” readr     2.1.4\nâœ” forcats   1.0.0     âœ” stringr   1.5.0\nâœ” ggplot2   3.4.4     âœ” tibble    3.2.1\nâœ” lubridate 1.9.3     âœ” tidyr     1.3.0\nâœ” purrr     1.0.2     \nâ”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€\nâœ– dplyr::filter() masks stats::filter()\nâœ– dplyr::lag()    masks stats::lag()\nâ„¹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(\"vegan\")\n\nLe chargement a nÃ©cessitÃ© le package : permute\nLe chargement a nÃ©cessitÃ© le package : lattice\nThis is vegan 2.6-4\n\nlibrary(\"nlme\")\n\n\nAttachement du package : 'nlme'\n\nL'objet suivant est masquÃ© depuis 'package:dplyr':\n\n    collapse\n\n\nLes modules sont installÃ©s sur votre ordinateur Ã  un endroit que vous pourrez retrouver avec la commande .libPaths()\nExercice. Ã€ partir dâ€™ici jusquâ€™Ã  la fin du cours, nous utiliserons RStudio. Ouvrez-le et familiarisez-vous avec lâ€™interface! Quelques petits trucs:\n\npour lancer une ligne, placez votre curseur sur la ligne, puis appuyez sur Ctrl+Enter\npour lancer une partie de code prÃ©cise, mettez le en surbrillance, puis Ctrl+Enter\nutilisez toujours le gestionnaire de projets, en haut Ã  droite!\ninstallez le module tidyverse\nlancez data(\"iris\") pour obtenir un tableau dâ€™exercice, puis cliquez sur lâ€™objet dans la fenÃªtre environnement"
  },
  {
    "objectID": "02-R.html#enfin",
    "href": "02-R.html#enfin",
    "title": "2Â  La science des donnÃ©es avec R",
    "section": "2.5 Enfinâ€¦",
    "text": "2.5 Enfinâ€¦\nComme une langue, on nâ€™apprend Ã  sâ€™exprimer en un langage informatique quâ€™en se mettant Ã  lâ€™Ã©preuve, ce que vous ferez tout au long de ce cours. Pour vous encourager, voici quelques trucs pour apprendre Ã  coder en R.\n\nR nâ€™aime pas lâ€™ambiguÃ¯tÃ©. Une simple virgule mal placÃ©e et il ne sait plus quoi faire. Cela peut Ãªtre frustrant au dÃ©but, mais cette rigiditÃ© est nÃ©cessaire pour effectuer du calcul scientifique.\nLe copier-coller est votre ami. En gardant Ã  lâ€™esprit que vous Ãªtre responsable de votre code et que vous respectez les droits dâ€™auteur, nâ€™ayez pas peur de copier-coller des lignes de code et de personnaliser par la suite.\nLâ€™erreur que vous obtenez: dâ€™autres lâ€™ont obtenue avant vous. Le site de question-rÃ©ponse stackoverflow est une ressource inestimable oÃ¹ des gens ayant postÃ© des questions ont reÃ§u des rÃ©ponses dâ€™experts (les meilleures rÃ©ponses et les meilleures questions apparaissent en premier). Apprenez Ã  chercher intelligemment des rÃ©ponses en formulant prÃ©cisÃ©ment vos questions!\nÃ‰tudiez et pratiquez. Les messages dâ€™erreur en R sont courants, mÃªme chez les personnes expÃ©rimentÃ©es. La meilleure maniÃ¨re dâ€™apprendre une langue est de la parler, dâ€™Ã©tudier ses susceptibilitÃ©s, de les tester dans une conversation, etc."
  },
  {
    "objectID": "02-R.html#petit-truc",
    "href": "02-R.html#petit-truc",
    "title": "2Â  La science des donnÃ©es avec R",
    "section": "2.6 Petit truc!",
    "text": "2.6 Petit truc!\nRStudio peut Ãªtre implÃ©mentÃ© avec des extensions. Lâ€™une dâ€™elle permet dâ€™ajuster votre style de code. Par exemple, vous voulez vous assurer que toutes les allocations sont bien effectuÃ©es avec des &lt;- et non pas des =, quâ€™il y a bien des espaces de part et dâ€™autre de &lt;-, que les retours de lignes sont bien placÃ©s, etc. Installez le module styler, et des options apparaÃ®tront dans le menu Addins comme Ã  la FigureÂ 2.9.\n\n\n\n\n\nFigureÂ 2.9: Lâ€™extension styler permet de formater votre code dans un style particulier"
  },
  {
    "objectID": "02-R.html#extra-jupyter",
    "href": "02-R.html#extra-jupyter",
    "title": "2Â  La science des donnÃ©es avec R",
    "section": "2.7 Extra: Utiliser R avec Jupyter",
    "text": "2.7 Extra: Utiliser R avec Jupyter\nPour utiliser R dans Jupyter notebook ou Jupyter lab, vous devez installer le module IRkernel dans la version de R que vous dÃ©sirez utiliser avec Jupyter, puis de lancer la commande IRkernel::installspec(). La prochaine fois que vous ouvrirez Jupyter, le noyau de R devrait apparaÃ®tre.\nJe nâ€™ai aucune expÃ©rience sur Mac, mais semble-t-il cela fonctionne comme en Linux. Ouvrez R Ã  partir dâ€™un terminal (R + Enter), puis lancez IRkernel::installspec() aprÃ¨s avoir installÃ© IRkernel. Si vous travaillez en Windows, il vous faudra lancer R par son chemin complet dans lâ€™invite de commande de Anaconda (Anaconda Powershell Prompt). Par exemple, ouvrir Anaconda Powershell Prompt, puis, si votre installation de R se trouve dans C:\\Program Files\\R\\R-3.6.2,\n(base) PS C:\\Users\\fifi&gt; cd \"C:\\Program Files\\R\\R-3.6.2\\bin\"\n(base) PS C:\\Program Files\\R\\R-3.6.2\\bin&gt; .\\R.exe\n\nR version 3.6.2 (2019-12-12) -- \"Dark and Stormy Night\"\nCopyright (C) 2019 The R Foundation for Statistical Computing\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\n\nR est un logiciel libre livrÃ© sans AUCUNE GARANTIE.\nVous pouvez le redistribuer sous certaines conditions.\nTapez 'license()' ou 'licence()' pour plus de dÃ©tails.\n\nR est un projet collaboratif avec de nombreux contributeurs.\nTapez 'contributors()' pour plus d'information et\n'citation()' pour la faÃ§on de le citer dans les publications.\n\nTapez 'demo()' pour des dÃ©monstrations, 'help()' pour l'aide\nen ligne ou 'help.start()' pour obtenir l'aide au format HTML.\nTapez 'q()' pour quitter R.\n\n&gt; install.packages(\"IRkernel\")\nInstallation du package dans 'C:/Users/fifi/Documents/R/win-library/3.6'\n(car 'lib' n'est pas spÃ©cifiÃ©)\n--- SVP sÃ©lectionner un miroir CRAN pour cette session ---\nessai de l'URL 'https://cloud.r-project.org/bin/windows/contrib/3.6/IRkernel_1.1.zip'\nContent type 'application/zip' length 138696 bytes (135 KB)\ndownloaded 135 KB\n\nle package 'IRkernel' a Ã©tÃ© dÃ©compressÃ© et les sommes MD5 ont Ã©tÃ© vÃ©rifiÃ©es avec succÃ©s\n\nLes packages binaires tÃ©lÃ©chargÃ©s sont dans\n       C:\\Users\\fifi\\AppData\\Local\\Temp\\Rtmp6xJtB3\\downloaded_packages\n\n&gt; IRkernel::installspec()\n[InstallKernelSpec] Installed kernelspec ir in C:\\Users\\fifi\\AppData\\Roaming\\jupyter\\kernels\\ir\n&gt; qui()"
  },
  {
    "objectID": "03-tableaux.html#les-collections-de-donnÃ©es",
    "href": "03-tableaux.html#les-collections-de-donnÃ©es",
    "title": "3Â  Organisation des donnÃ©es et opÃ©rations sur des tableaux",
    "section": "3.1 Les collections de donnÃ©es",
    "text": "3.1 Les collections de donnÃ©es\nDans le chapitreÂ 2, nous avons survolÃ© diffÃ©rents types dâ€™objets : rÃ©els, entiers, chaÃ®nes de caractÃ¨res et boolÃ©ens. Les donnÃ©es peuvent appartenir Ã  dâ€™autres types : dates, catÃ©gories ordinales (ordonnÃ©es : faible, moyen, Ã©levÃ©) et nominales (non ordonnÃ©es : espÃ¨ces, cultivars, couleurs, unitÃ© pÃ©dologique, etc.). Comme mentionnÃ© en dÃ©but de chapitre, une donnÃ©e est une valeur associÃ©e Ã  une variable. Les donnÃ©es peuvent Ãªtre organisÃ©es en collections.\nNous avons aussi vu au chapitreÂ 2 que la maniÃ¨re privilÃ©giÃ©e dâ€™organiser des donnÃ©es Ã©tait sous forme de tableaux. De maniÃ¨re gÃ©nÃ©rale, un tableau de donnÃ©es est une organisation de donnÃ©es en deux dimensions, comportant des lignes et des colonnes. Il est prÃ©fÃ©rable de respecter la convention selon laquelle les lignes sont des observations et les colonnes sont des variables. Ainsi, un tableau est une liste de vecteurs de mÃªme longueur, chaque vecteur reprÃ©sentant une variable. Chaque variable est libre de prendre le type de donnÃ©es appropriÃ©. La position dâ€™une donnÃ©e dans le vecteur correspond Ã  une observation. Lorsque les vecteurs sont posÃ©s les uns Ã  cÃ´tÃ© des autres, la position dans le vecteur devient une ligne qui dÃ©finit les valeurs des variables dâ€™une observation.\nImaginez que vous consignez des donnÃ©es mÃ©tÃ©orologiques comme les prÃ©cipitations totales ou la tempÃ©rature moyenne pour chaque jour, pendant une semaine sur les sites A, B et C. Chaque site possÃ¨de ses propres caractÃ©ristiques, comme la position en longitude-latitude. Il est redondant de rÃ©pÃ©ter la position du site pour chaque jour de la semaine. Vous prÃ©fÃ©rerez crÃ©er deux tableaux : un pour dÃ©crire vos observations, et un autre pour dÃ©crire les sites. De cette maniÃ¨re, vous crÃ©ez une collection de tableaux interreliÃ©s : une base de donnÃ©es. Nous couvrirons cette notion un peu plus loin. R peut soutirer des donnÃ©es des bases de donnÃ©es grÃ¢ce au module DBI, qui nâ€™est pas couvert Ã  ce stade de dÃ©veloppement du cours.\nDans R, les donnÃ©es structurÃ©es en tableaux, ainsi que les opÃ©rations sur les tableaux, peuvent Ãªtre gÃ©rÃ©es grÃ¢ce aux modules readr, dplyr et tidyr, tous des modules faisant partie du mÃ©ta-module tidyverse, qui est un genre de Microsoft Office sur R : plusieurs modules fonctionnant en interopÃ©rabilitÃ©. Mais avant de se lancer dans lâ€™utilisation de ces modules, voyons quelques rÃ¨gles Ã  suivre pour bien structurer ses donnÃ©es en format tidy, un jargon du tidyverse qui signifie proprement organisÃ©."
  },
  {
    "objectID": "03-tableaux.html#organiser-un-tableau-de-donnÃ©es",
    "href": "03-tableaux.html#organiser-un-tableau-de-donnÃ©es",
    "title": "3Â  Organisation des donnÃ©es et opÃ©rations sur des tableaux",
    "section": "3.2 Organiser un tableau de donnÃ©es",
    "text": "3.2 Organiser un tableau de donnÃ©es\nAfin de repÃ©rer chaque cellule dâ€™un tableau, on attribue Ã  chaque ligne et Ã  chaque colonne un identifiant unique, que lâ€™on nomme indice pour les lignes et entÃªte pour les colonnes.\n\nRÃ¨gle no 1. Une variable par colonne, une observation par ligne, une valeur par cellule.\n\nLes unitÃ©s expÃ©rimentales sont dÃ©crites par une ou plusieurs variables, par des chiffres ou des lettres. Chaque variable devrait Ãªtre prÃ©sente en une seule colonne, et chaque ligne devrait correspondre Ã  une unitÃ© expÃ©rimentale oÃ¹ ces variables ont Ã©tÃ© mesurÃ©es. La rÃ¨gle parait simple, mais elle est rarement respectÃ©e. Prenez par exemple le tableau suivant.\n\n\nâ”€â”€ Attaching core tidyverse packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 2.0.0 â”€â”€\nâœ” dplyr     1.1.3     âœ” readr     2.1.4\nâœ” forcats   1.0.0     âœ” stringr   1.5.0\nâœ” ggplot2   3.4.4     âœ” tibble    3.2.1\nâœ” lubridate 1.9.3     âœ” tidyr     1.3.0\nâœ” purrr     1.0.2     \nâ”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€\nâœ– dplyr::filter() masks stats::filter()\nâœ– dplyr::lag()    masks stats::lag()\nâ„¹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\n\n\nTableÂ 3.1: Rendements obtenus sur les sites expÃ©rimentaux selon les traitements.\n\n\nSite\nTraitement A\nTraitement B\nTraitement C\n\n\n\n\nSainte-Souris\n4.1\n8.2\n6.8\n\n\nSainte-Fourmi\n5.8\n5.9\nNA\n\n\nSaint-Ours\n2.9\n3.4\n4.6\n\n\n\n\n\n\nQuâ€™est-ce qui cloche avec ce tableau? Chaque ligne est une observation, mais contient plusieurs observations dâ€™une mÃªme variable, le rendement, qui devient Ã©talÃ© sur plusieurs colonnes. Ã€ bien y penser, le type de traitement est une variable et le rendement en est une autre:\n\n\n\n\nTableÂ 3.2: Rendements obtenus sur les sites expÃ©rimentaux selon les traitements.\n\n\nSite\nTraitement\nRendement\n\n\n\n\nSainte-Souris\nTraitement A\n4.1\n\n\nSainte-Souris\nTraitement B\n8.2\n\n\nSainte-Souris\nTraitement C\n6.8\n\n\nSainte-Fourmi\nTraitement A\n5.8\n\n\nSainte-Fourmi\nTraitement B\n5.9\n\n\nSainte-Fourmi\nTraitement C\nNA\n\n\nSaint-Ours\nTraitement A\n2.9\n\n\nSaint-Ours\nTraitement B\n3.4\n\n\nSaint-Ours\nTraitement C\n4.6\n\n\n\n\n\n\nPlus prÃ©cisÃ©ment, lâ€™expression Ã  bien y penser suggÃ¨re une rÃ©flexion sur la signification des donnÃ©es. Certaines variables peuvent parfois Ãªtre intÃ©grÃ©es dans une mÃªme colonne, parfois pas. Par exemple, les concentrations en cuivre, zinc et plomb dans un sol contaminÃ© peuvent Ãªtre placÃ©es dans la mÃªme colonne â€œConcentrationâ€ ou dÃ©clinÃ©es en plusieurs colonnes Cu, Zn et Pb. La premiÃ¨re version trouvera son utilitÃ© pour crÃ©er des graphiques (chapitreÂ 4), alors que la deuxiÃ¨me favorise le traitement statistique (chapitreÂ 7). Il est possible de passer dâ€™un format Ã  lâ€™autre grÃ¢ce Ã  la fonction pivot_longer() et pivot_wider() du module tidyr.\n\nRÃ¨gle no 2. Un tableau par unitÃ© observationnelle: ne pas rÃ©pÃ©ter les informations.\n\nReprenons la mÃªme expÃ©rience. Supposons que vous mesurez la prÃ©cipitation Ã  lâ€™Ã©chelle du site.\n\n\n\n\nTableÂ 3.3: Rendements et prÃ©cipitations obtenus sur les sites expÃ©rimentaux selon les traitements.\n\n\nSite\nTraitement\nRendement\nPrÃ©cipitations\n\n\n\n\nSainte-Souris\nTraitement A\n4.1\n813\n\n\nSainte-Souris\nTraitement B\n8.2\n813\n\n\nSainte-Souris\nTraitement C\n6.8\n813\n\n\nSainte-Fourmi\nTraitement A\n5.8\n642\n\n\nSainte-Fourmi\nTraitement B\n5.9\n642\n\n\nSainte-Fourmi\nTraitement C\nNA\n642\n\n\nSaint-Ours\nTraitement A\n2.9\n1028\n\n\nSaint-Ours\nTraitement B\n3.4\n1028\n\n\nSaint-Ours\nTraitement C\n4.6\n1028\n\n\n\n\n\n\nSegmenter lâ€™information en deux tableaux serait prÃ©fÃ©rable.\n\n\n\n\nTableÂ 3.4: PrÃ©cipitations sur les sites expÃ©rimentaux.\n\n\nSite\nPrÃ©cipitations\n\n\n\n\nSainte-Souris\n813\n\n\nSainte-Fourmi\n642\n\n\nSaint-Ours\n1028\n\n\n\n\n\n\nLes tableaux TableÂ 3.2 et TableÂ 3.4, ensemble, forment une base de donnÃ©es (collection organisÃ©e de tableaux). Les opÃ©rations de fusion entre les tableaux peuvent Ãªtre effectuÃ©es grÃ¢ce aux fonctions de jointure (left_join(), par exemple) du module tidyr. Une jointure de TableÂ 3.4 vers TableÂ 3.2 donnera le tableau TableÂ 3.3.\n\nRÃ¨gle no 3. Ne pas bousiller les donnÃ©es.\n\nPar exemple.\n\nAjouter des commentaires dans des cellules. Si une cellule mÃ©rite dâ€™Ãªtre commentÃ©e, il est prÃ©fÃ©rable de placer les commentaires soit dans un fichier dÃ©crivant le tableau de donnÃ©es, soit dans une colonne de commentaire juxtaposÃ©e Ã  la colonne de la variable Ã  commenter. Par exemple, si vous nâ€™avez pas mesurÃ© le pH pour une observation, nâ€™Ã©crivez pas â€œÃ©chantillon contaminÃ©â€ dans la cellule, mais annoter dans un fichier dâ€™explication que lâ€™Ã©chantillon no X a Ã©tÃ© contaminÃ©. Si les commentaires sont systÃ©matiques, il peut Ãªtre pratique de les inscrire dans une colonne commentaire_pH.\nInscription non systÃ©matique. Il arrive souvent que des catÃ©gories dâ€™une variable ou que des valeurs manquantes soient annotÃ©es diffÃ©remment. Il arrive mÃªme que le sÃ©parateur dÃ©cimal soit non systÃ©matique, parfois notÃ© par un point, parfois par une virgule. Par exemple, une fois importÃ©s dans votre session, les catÃ©gories St-Ours et Saint-Ours seront traitÃ©es comme deux catÃ©gories distinctes. De mÃªme, les cellules correspondant Ã  des valeurs manquantes ne devraient pas Ãªtre inscrites parfois avec une cellule vide, parfois avec un point, parfois avec un tiret ou avec la mention NA. Le plus simple est de laisser systÃ©matiquement ces cellules vides.\nInclure des notes dans un tableau. La rÃ¨gle â€œune colonne, une variableâ€ nâ€™est pas respectÃ©e si on ajoute des notes un peu nâ€™importe oÃ¹ sous ou Ã  cÃ´tÃ© du tableau.\nAjouter des sommaires. Si vous ajoutez une ligne sous un tableau comprenant la moyenne de chaque colonne, quâ€™est-ce qui arrivera lorsque vous importerez votre tableau dans votre session de travail? La ligne sera considÃ©rÃ©e comme une observation supplÃ©mentaire.\nInclure une hiÃ©rarchie dans les entÃªtes. Afin de consigner des donnÃ©es de texture du sol, comprenant la proportion de sable, de limon et dâ€™argile, vous organisez votre entÃªte en plusieurs lignes. Une ligne pour la catÃ©gorie de donnÃ©e, Texture, fusionnÃ©e sur trois colonnes, puis trois colonnes intitulÃ©es Sable, Limon et Argile. Votre tableau est joli, mais il ne pourra pas Ãªtre importÃ© conformÃ©ment dans un votre session de calcul : on recherche une entÃªte unique par colonne. Votre tableau de donnÃ©es devrait plutÃ´t porter les entÃªtes Texture sable, Texture limon et Texture argile. Un conseil : rÃ©server le travail esthÃ©tique Ã  la toute fin dâ€™un flux de travail."
  },
  {
    "objectID": "03-tableaux.html#formats-de-tableau",
    "href": "03-tableaux.html#formats-de-tableau",
    "title": "3Â  Organisation des donnÃ©es et opÃ©rations sur des tableaux",
    "section": "3.3 Formats de tableau",
    "text": "3.3 Formats de tableau\nPlusieurs outils sont Ã  votre disposition pour crÃ©er des tableaux. Je vous prÃ©sente ici les plus communs.\n\n3.3.1 xls ou xlsx\nMicrosoft Excel est un logiciel de type tableur, ou chiffrier Ã©lectronique. Lâ€™ancien format xls a Ã©tÃ© remplacÃ© par le format xlsx avec lâ€™arrivÃ©e de Microsoft Office 2010. Il sâ€™agit dâ€™un format propriÃ©taire, dont lâ€™alternative libre la plus connue est le format ods, popularisÃ© par la suite bureautique LibreOffice. Les formats xls, xlsx ou ods sont davantage utilisÃ©s comme outils de calcul que dâ€™entreposage de donnÃ©es. Ils contiennent des formules, des graphiques, du formatage de cellule, etc. Je ne les recommande pas pour stocker des donnÃ©es.\n\n\n3.3.2 csv\nLe format csv, pour comma separated values, est un fichier texte, que vous pouvez ouvrir avec nâ€™importe quel Ã©diteur de texte brut (Bloc note, VSCode, Notepad++, etc.). Chaque colonne doit Ãªtre dÃ©limitÃ©e par un caractÃ¨re cohÃ©rent (conventionnellement une virgule, mais en franÃ§ais un point-virgule ou une tabulation pour Ã©viter la confusion avec le sÃ©parateur dÃ©cimal) et chaque ligne du tableau est un retour de ligne. Il est possible dâ€™ouvrir et dâ€™Ã©diter les fichiers csv dans un Ã©diteur texte, mais il est plus pratique de les ouvrir avec des tableurs (LibreOffice Calc, Microsoft Excel, Google Sheets, etc.).\nEncodage des fichiers texte. Puisque le format csv est un fichier texte, un souci particulier doit Ãªtre portÃ© sur la maniÃ¨re dont le texte est encodÃ©. Les caractÃ¨res accentuÃ©s pourraient Ãªtre importÃ©s incorrectement si vous importez votre tableau en spÃ©cifiant le mauvais encodage. Pour les fichiers en langues occidentales, lâ€™encodage UTF-8 devrait Ãªtre utilisÃ©. Toutefois, par dÃ©faut, Excel utilise un encodage de Microsoft. Si le csv a Ã©tÃ© gÃ©nÃ©rÃ© par Excel, il est prÃ©fÃ©rable de lâ€™ouvrir avec votre Ã©diteur texte et de lâ€™enregistrer dans lâ€™encodage UTF-8.\n\n\n3.3.3 json\nComme le format csv, le format json indique un fichier en texte clair. En permettant des structures de tableaux emboÃ®tÃ©s et en ne demandant pas que chaque colonne ait la mÃªme longueur, le format json permet plus de souplesse que le format csv, mais il est plus compliquÃ© Ã  consulter et prend davantage dâ€™espace sur le disque que le csv. Il est utilisÃ© davantage pour le partage de donnÃ©es des applications web, mais en ce qui concerne la matiÃ¨re du cours, ce format est surtout utilisÃ© pour les donnÃ©es gÃ©orÃ©fÃ©rencÃ©es. Lâ€™encodage est gÃ©rÃ© de la mÃªme maniÃ¨re quâ€™un fichier csv.\n\n\n3.3.4 SQLite\nSQLite est une application pour les bases de donnÃ©es relationnelles de type SQL qui nâ€™a pas besoin de serveur pour fonctionner. Les bases de donnÃ©es SQLite sont encodÃ©s dans des fichiers portant lâ€™extension db, qui peuvent Ãªtre facilement partagÃ©s.\n\n\n3.3.5 Suggestion\nEn csv pour les petits tableaux, en sqlite pour les bases de donnÃ©es plus complexes. Ce cours se concentre toutefois sur les donnÃ©es de type csv."
  },
  {
    "objectID": "03-tableaux.html#entreposer-ses-donnÃ©es",
    "href": "03-tableaux.html#entreposer-ses-donnÃ©es",
    "title": "3Â  Organisation des donnÃ©es et opÃ©rations sur des tableaux",
    "section": "3.4 Entreposer ses donnÃ©es",
    "text": "3.4 Entreposer ses donnÃ©es\nLa maniÃ¨re la plus sÃ©curisÃ©e pour entreposer ses donnÃ©es est de les confiner dans une base de donnÃ©es sÃ©curisÃ©e sur un serveur sÃ©curisÃ© dans un environnement sÃ©curisÃ© et dâ€™encrypter les communications. Câ€™est aussiâ€¦ la maniÃ¨re la moins accessible. Des espaces de stockage nuagiques, comme Dropbox ou dâ€™autres options similaires, peuvent Ãªtre pratiques pour les backups et le partage des donnÃ©es avec une Ã©quipe de travail (qui risque en retour de bousiller vos donnÃ©es). Le suivi de version est possible chez certains fournisseurs dâ€™espace de stockage. Mais pour un suivi de version plus rigoureux, les espaces de dÃ©veloppement (comme GitHub et GitLab) sont plus appropriÃ©s (couverts au chapitreÂ 5). Dans tous les cas, il est important de garder (1) des copies anciennes pour y revenir en cas dâ€™erreurs et (2) un petit fichier dÃ©crivant les changements effectuÃ©s sur les donnÃ©es."
  },
  {
    "objectID": "03-tableaux.html#manipuler-des-donnÃ©es-en-mode-tidyverse",
    "href": "03-tableaux.html#manipuler-des-donnÃ©es-en-mode-tidyverse",
    "title": "3Â  Organisation des donnÃ©es et opÃ©rations sur des tableaux",
    "section": "3.5 Manipuler des donnÃ©es en mode tidyverse",
    "text": "3.5 Manipuler des donnÃ©es en mode tidyverse\nLe mÃ©ta-module tidyverse regroupe une collection de prÃ©cieux modules pour lâ€™analyse de donnÃ©es en R. Il permet dâ€™importer des donnÃ©es dans votre session de travail avec readr, de les explorer avec le module de visualisation ggplot2, de les transformer avec tidyr et dplyr et de les exporter avec readr. Les tableaux de classe data.frame, comme ceux de la plus moderne classe tibble, peuvent Ãªtre manipulÃ©s Ã  travers le flux de travail pour lâ€™analyse et la modÃ©lisation. Comme ce sera le cas pour le chapitre sur la visualisation, ce chapitre est loin de couvrir les nombreuses fonctionnalitÃ©s qui sont offertes dans le tidyverse.\n\n3.5.1 Importer vos donnÃ©es dans votre session de travail\nSupposons que vous avez bien organisÃ© vos donnÃ©es en mode tidy. Pour les importer dans votre session et commencer Ã  les inspecter, vous lancerez une des commandes du module readr, dÃ©crites dans la documentation dÃ©diÃ©e.\n\nread_csv() si le sÃ©parateur de colonne est une virgule\nread_csv2() si le sÃ©parateur de colonne est un point-virgule et que le sÃ©parateur dÃ©cimal est une virgule\nread_tsv() si le sÃ©parateur de colonne est une tabulation\nread_table() si le sÃ©parateur de colonne est un espace blanc\nread_delim() si le sÃ©parateur de colonne est un autre caractÃ¨re (comme le point-virgule) que vous spÃ©cifierez dans lâ€™argument delim = \";\"\n\nLes principaux arguments sont les suivants.\n\nfile: le chemin vers le fichier. Ce chemin peut aussi bien Ãªtre une adresse locale (data/â€¦) quâ€™une adresse internet (https://â€¦).\ndelim: le symbole dÃ©limitant les colonnes dans le cas de read_delim.\ncol_names: si TRUE, la premiÃ¨re ligne est lâ€™entÃªte du tableau, sinon FALSE. Si vous spÃ©cifiez un vecteur numÃ©rique, ce sont les numÃ©ros des lignes utilisÃ©es pour le nom de lâ€™entÃªte. Si vous utilisez un vecteur de caractÃ¨res, ce sont les noms des colonnes que vous dÃ©sirez donner Ã  votre tableau.\nna: le symbole spÃ©cifiant une valeur manquante. Lâ€™argument na='' signifie que les cellules vides sont des donnÃ©es manquantes. Si les valeurs manquantes ne sont pas uniformes, vous pouvez les indiquer dans un vecteur, par exemple na = c(\"\", \"NA\", \"NaN\", \".\", \"-\").\nlocal: cet argument prend une fonction local() qui peut inclure des arguments de format de temps, mais aussi dâ€™encodage (voir documentation)\n\nDâ€™autres arguments peuvent Ãªtre spÃ©cifiÃ©s au besoin, et les rÃ©pÃ©ter ici dupliquerait lâ€™information de la documentation de la fonction read_csv de readr.\nJe dÃ©conseille dâ€™importer des donnÃ©es en format xls ou xlsx. Si toutefois cela vous convient, je vous rÃ©fÃ¨re au module readxl.\nLâ€™aide-mÃ©moire de readr (FigureÂ 3.1) est Ã  afficher prÃ¨s de soi.\n\n\n\n\n\nFigureÂ 3.1: Aide-mÃ©moire de readr, Source: https://rstudio.github.io/cheatsheets/data-import.pdf\n\n\n\n\nNous allons charger des donnÃ©es de culture de la chicoutÃ© (Rubus chamaemorus), un petit fruit nordique, tirÃ© de Parent et al.Â (2013). Ouvrons dâ€™abord le fichier pour vÃ©rifier les sÃ©parateurs de colonnes et de dÃ©cimales (FigureÂ 3.2).\n\n\n\n\n\nFigureÂ 3.2: AperÃ§u brut dâ€™un fichier csv.\n\n\n\n\nLe sÃ©parateur de colonnes est un point-virgule et le dÃ©cimal est une virgule.\nAvec Atom, mon Ã©diteur texte prÃ©fÃ©rÃ© (il y en a dâ€™autres), je vais dans Edit &gt; Select Encoding et jâ€™obtiens bien le UTF-8 (FigureÂ 3.3).\n\n\n\n\n\nFigureÂ 3.3: Changer lâ€™encodage dâ€™un fichier csv.\n\n\n\n\nNous allons donc utiliser read_csv2() avec ses arguments par dÃ©faut.\n\nlibrary(\"tidyverse\")\nchicoute &lt;- read_csv2(\"data/chicoute.csv\")\n\nâ„¹ Using \"','\" as decimal and \"'.'\" as grouping mark. Use `read_delim()` for more control.\n\n\nRows: 90 Columns: 31\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \";\"\nchr  (5): CodeTourbiere, Ordre, Traitement, DemiParcelle, SousTraitement\ndbl (26): ID, Site, Latitude_m, Longitude_m, Rendement_g_5m2, TotalRamet_nom...\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nQuelques commandes utiles inspecter le tableau:\n\nhead() prÃ©sente lâ€™entÃªte du tableau, soit ses 6 premiÃ¨res lignes\nstr() et glimpse() prÃ©sentent les variables du tableau et leur type - glimpse()est la fonction tidyverse et str() est la fonction classique (je prÃ©fÃ¨re str())\nsummary() prÃ©sente des statistiques de base du tableau\nnames() ou colnames() sort les noms des colonnes sous forme dâ€™un vecteur\ndim() donne les dimensions du tableau, ncol() son nombre de colonnes et nrow() son nombre de lignes\nskim est une fonction du module skimr montrant un portrait graphique et numÃ©rique du tableau\n\nExtra 1. Plusieurs modules ne se trouvent pas dans les dÃ©pÃ´ts CRAN, mais sont disponibles sur GitHub. Pour les installer, installez dâ€™abord le module devtools disponible sur CRAN. Vous pourrez alors installer les packages de GitHub comme on le fait avec le package skimr.\nExtra 2. Lorsque je dÃ©sire utiliser une fonction, mais sans charger le module dans la session, jâ€™utilise la notation module::fonction. Comme dans ce cas, pour skimr.\n\nskimr::skim(chicoute)\n\n\nData summary\n\n\nName\nchicoute\n\n\nNumber of rows\n90\n\n\nNumber of columns\n31\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n5\n\n\nnumeric\n26\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\nCodeTourbiere\n0\n1.00\n1\n4\n0\n12\n0\n\n\nOrdre\n0\n1.00\n1\n2\n0\n20\n0\n\n\nTraitement\n50\n0.44\n6\n11\n0\n2\n0\n\n\nDemiParcelle\n50\n0.44\n4\n5\n0\n2\n0\n\n\nSousTraitement\n50\n0.44\n1\n7\n0\n3\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nID\n0\n1.00\n45.50\n26.12\n1.00\n23.25\n45.50\n67.75\n90.00\nâ–‡â–‡â–‡â–‡â–‡\n\n\nSite\n0\n1.00\n6.33\n5.49\n1.00\n2.00\n4.00\n9.00\n20.00\nâ–‡â–ƒâ–â–â–\n\n\nLatitude_m\n0\n1.00\n5701839.86\n1915.50\n5695688.00\n5701868.50\n5702129.00\n5702537.00\n5706394.00\nâ–â–‚â–…â–‡â–\n\n\nLongitude_m\n0\n1.00\n485295.54\n6452.33\n459873.00\n485927.00\n486500.00\n486544.75\n491955.00\nâ–â–â–â–‚â–‡\n\n\nRendement_g_5m2\n50\n0.44\n13.33\n21.56\n0.00\n0.00\n0.95\n15.63\n72.44\nâ–‡â–â–â–â–\n\n\nTotalRamet_nombre_m2\n0\n1.00\n251.26\n156.06\n40.74\n122.70\n212.92\n347.80\n651.90\nâ–‡â–‡â–ƒâ–‚â–‚\n\n\nTotalVegetatif_nombre_m2\n4\n0.96\n199.02\n139.13\n22.92\n86.26\n161.25\n263.78\n580.60\nâ–‡â–‡â–‚â–‚â–\n\n\nTotalFloral_nombre_m2\n4\n0.96\n52.08\n40.41\n4.80\n22.92\n43.00\n69.52\n198.62\nâ–‡â–…â–‚â–â–\n\n\nTotalMale_nombre_m2\n4\n0.96\n24.40\n26.87\n0.00\n3.30\n15.28\n36.51\n104.41\nâ–‡â–‚â–‚â–â–\n\n\nTotalFemelle_nombre_m2\n4\n0.96\n27.53\n29.83\n2.55\n10.34\n17.19\n31.96\n187.17\nâ–‡â–â–â–â–\n\n\nFemelleFruit_nombre_m2\n18\n0.80\n19.97\n23.79\n0.40\n7.64\n11.46\n22.83\n157.88\nâ–‡â–‚â–â–â–\n\n\nFemelleAvorte_nombre_m2\n4\n0.96\n8.49\n14.52\n0.00\n1.27\n3.07\n10.14\n76.80\nâ–‡â–â–â–â–\n\n\nSterileFleur_nombre_m2\n4\n0.96\n0.26\n0.71\n0.00\n0.00\n0.00\n0.00\n3.82\nâ–‡â–â–â–â–\n\n\nC_pourc\n0\n1.00\n50.28\n1.61\n46.72\n49.14\n50.45\n51.58\n53.83\nâ–ƒâ–†â–…â–‡â–\n\n\nN_pourc\n0\n1.00\n2.20\n0.40\n1.53\n1.89\n2.12\n2.58\n3.10\nâ–ƒâ–‡â–ƒâ–ƒâ–‚\n\n\nP_pourc\n0\n1.00\n0.14\n0.04\n0.07\n0.12\n0.14\n0.16\n0.23\nâ–ƒâ–†â–‡â–‚â–‚\n\n\nK_pourc\n0\n1.00\n0.89\n0.27\n0.35\n0.69\n0.86\n1.13\n1.54\nâ–ƒâ–‡â–‡â–‡â–\n\n\nCa_pourc\n0\n1.00\n0.39\n0.10\n0.19\n0.32\n0.37\n0.44\n0.88\nâ–…â–‡â–‚â–â–\n\n\nMg_pourc\n0\n1.00\n0.50\n0.08\n0.36\n0.45\n0.48\n0.52\n0.86\nâ–‡â–‡â–‚â–â–\n\n\nS_pourc\n0\n1.00\n0.13\n0.04\n0.07\n0.11\n0.13\n0.14\n0.28\nâ–…â–‡â–‚â–â–\n\n\nB_pourc\n0\n1.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\nâ–‚â–…â–ƒâ–‡â–ƒ\n\n\nCu_pourc\n0\n1.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\nâ–‡â–â–â–â–\n\n\nZn_pourc\n0\n1.00\n0.01\n0.00\n0.00\n0.01\n0.01\n0.01\n0.02\nâ–‡â–‡â–‚â–â–\n\n\nMn_pourc\n0\n1.00\n0.03\n0.03\n0.00\n0.01\n0.03\n0.05\n0.10\nâ–‡â–…â–ƒâ–‚â–\n\n\nFe_pourc\n0\n1.00\n0.02\n0.01\n0.01\n0.01\n0.01\n0.02\n0.05\nâ–‡â–‚â–â–â–\n\n\nAl_pourc\n0\n1.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.00\n0.01\nâ–‡â–…â–â–â–\n\n\n\n\n\nExercice. Inspectez le tableau.\n\n\n3.5.2 Comment sÃ©lectionner et filtrer des donnÃ©es ?\nOn utilise le terme sÃ©lectionner lorsque lâ€™on dÃ©sire choisir une ou plusieurs lignes et colonnes dâ€™un tableau (la plupart du temps des colonnes). Lâ€™action de filtrer signifie de sÃ©lectionner des lignes selon certains critÃ¨res.\n\n3.5.2.1 SÃ©lectionner\nVoici 4 maniÃ¨res de sÃ©lectionner une colonne en R.\n\nUne mÃ©thode rapide mais peu expressive consiste Ã  indiquer les valeurs numÃ©riques de lâ€™indice de la colonne entre des crochets. Il sâ€™agit dâ€™appeler le tableau suivi de crochets. Lâ€™intÃ©rieur des crochets comprend deux Ã©lÃ©ments sÃ©parÃ©s par une virgule. Le premier Ã©lÃ©ment sert Ã  filtrer selon lâ€™indice, le deuxiÃ¨me sert Ã  sÃ©lectionner selon lâ€™indice. Ainsi:\n\nchicoute[, 1]: sÃ©lectionner la premiÃ¨re colonne\nchicoute[, 1:10]: sÃ©lectionner les 10 premiÃ¨res colonnes\nchicoute[, c(2, 4, 5)]: sÃ©lectionner les colonnes 2, 4 et 5\nchicoute[c(10, 13, 20), c(2, 4, 5)]: sÃ©lectionner les colonnes 2, 4 et 5 et les lignes 10, 13 et 20.\n\nUne autre mÃ©thode rapide, mais plus expressive, consiste Ã  appeler le tableau, suivi du symbole $, puis le nom de la colonne, e.g.Â chicoute$Site.\nOu bien dâ€™inscrire le nom de la colonne, ou du vecteur des colonnes, entre des crochets suivant le nom du tableau, câ€™est-Ã -dire chicoute[c(\"Site\", \"Latitude_m\", \"Longitude_m\")].\nEnfin, dans une sÃ©quence dâ€™opÃ©rations en mode pipeline (chaque opÃ©ration est mise Ã  la suite de la prÃ©cÃ©dente en plaÃ§ant le pipe %&gt;% entre chacune), il peut Ãªtre prÃ©fÃ©rable de sÃ©lectionner des colonnes avec la fonction select(), i.e.\n\nchicoute %&gt;%\n  select(Site, Latitude_m, Longitude_m)\n\nTruc. La plupart des IDE, comme RStudio, peuvent vous proposer des colonnes dans une liste. AprÃ¨s avoir saisi le $, taper sur la touche de tabulation: vous pourrez sÃ©lectionner la colonne dans une liste dÃ©filante (FigureÂ 3.4).\n\n\n\n\n\n\nFigureÂ 3.4: AutocomplÃ©tion dans RStudio.\n\n\n\n\nLa fonction select() permet aussi de travailler en exclusion. Ainsi pour enlever des colonnes, on placera un - (signe de soustraction) devant le nom de la colonne.\nâš ï¸ Attention. Plusieurs modules utilisent la fonction select (et filter, plus bas). Lorsque vous lancez select et que vous obtenez un message dâ€™erreur comme\nError in select(., ends_with(\"pourc\")) : \n  argument inutilisÃ© (ends_with(\"pourc\"))\nil se pourrait bien que R utilise la fonction select dâ€™un autre module. Pour spÃ©cifier que vous dÃ©sirez la fonction select du module dplyr, spÃ©cifiez dplyr::select.\nDâ€™autre arguments de select() permettent une sÃ©lection rapide. Par exemple, pour obtenir les colonnes contenant des pourcentages:\n\nchicoute %&gt;%\n  select(ends_with(\"pourc\")) %&gt;%\n  head(3)\n\n# A tibble: 3 Ã— 13\n  C_pourc N_pourc P_pourc K_pourc Ca_pourc Mg_pourc S_pourc B_pourc Cu_pourc\n    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;\n1    51.5    1.72  0.108     1.21    0.435    0.470  0.0976 0.00258 0.000175\n2    51.3    2.18  0.0985    1.22    0.337    0.439  0.0996 0.00258 0.000407\n3    50.6    2.12  0.0708    1.05    0.373    0.420  0.104  0.00258 0.000037\n# â„¹ 4 more variables: Zn_pourc &lt;dbl&gt;, Mn_pourc &lt;dbl&gt;, Fe_pourc &lt;dbl&gt;,\n#   Al_pourc &lt;dbl&gt;\n\n\n\n\n3.5.2.2 Filtrer\nComme câ€™est le cas de la sÃ©lection, on pourra filtrer un tableau de plusieurs maniÃ¨res. Jâ€™ai dÃ©jÃ  prÃ©sentÃ© comment filtrer selon les indices des lignes. Les autres maniÃ¨res reposent nÃ©anmoins sur une opÃ©ration logique ==, &lt;, &gt; ou %in% (le %in% signifie se trouve parmi et peut Ãªtre suivi dâ€™un vecteur de valeurs que lâ€™on dÃ©sire accepter).\nLes conditions boolÃ©ennes peuvent Ãªtre combinÃ©es avec les opÃ©rateurs et, &, et ou, |. Pour rappel,\n\n\n\nOpÃ©ration\nRÃ©sultat\n\n\n\n\nVrai et Vrai\nVrai\n\n\nVrai et Faux\nFaux\n\n\nFaux et Faux\nFaux\n\n\nVrai ou Vrai\nVrai\n\n\nVrai ou Faux\nVrai\n\n\nFaux ou Faux\nFaux\n\n\n\n\nLa mÃ©thode classique consiste Ã  appliquer une opÃ©ration logique entre les crochets, par exemple chicoute[chicoute$CodeTourbiere == \"BEAU\", ]\nLa mÃ©thode tidyverse, plus pratique en mode pipeline, passe par la fonction filter(), i.e.\n\nchicoute %&gt;%\n  filter(CodeTourbiere == \"BEAU\")\nCombiner le tout.\n\nchicoute %&gt;%\n  filter(Ca_pourc &lt; 0.4 & CodeTourbiere %in% c(\"BEAU\", \"MB\", \"WTP\")) %&gt;%\n  select(contains(\"pourc\"))\n\n# A tibble: 4 Ã— 13\n  C_pourc N_pourc P_pourc K_pourc Ca_pourc Mg_pourc S_pourc B_pourc Cu_pourc\n    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;\n1    51.3    2.18  0.0985   1.22     0.337    0.439  0.0996 0.00258 0.000407\n2    50.6    2.12  0.0708   1.05     0.373    0.420  0.104  0.00258 0.000037\n3    53.8    2.04  0.115    0.947    0.333    0.472  0.106  0.00258 0.000037\n4    52.6    2.11  0.0847   0.913    0.328    0.376  0.111  0.00296 0.000037\n# â„¹ 4 more variables: Zn_pourc &lt;dbl&gt;, Mn_pourc &lt;dbl&gt;, Fe_pourc &lt;dbl&gt;,\n#   Al_pourc &lt;dbl&gt;\n\n\n\n\n\n3.5.3 Le format long et le format large\nDans le tableau chicoute, chaque Ã©lÃ©ment possÃ¨de sa propre colonne. Si lâ€™on voulait mettre en graphique les boxplot des facettes de concentrations dâ€™azote, de phosphore et de potassium dans les diffÃ©rentes tourbiÃ¨res, il faudrait obtenir une seule colonne de concentrations.\nPour ce faire, nous utiliserons la fonction pivot_longer(). Lâ€™argument obligatoire (excluant le tableau, qui est implicite dans la chaÃ®ne dâ€™opÃ©rations), est cols, le nom des colonnes Ã  allonger. Pour obtenir des noms de colonnes allongÃ©es personnalisÃ©es, on spÃ©cifie le nom des variables consistant aux anciens noms de colonnes avec names_to et celui de la nouvelle colonne contenant les valeurs dans values_to. La suite consiste Ã  dÃ©crire les colonnes Ã  inclure ou Ã  exclure. Dans le cas qui suit, jâ€™exclue CodeTourbiere de la refonte et jâ€™utilise slice_head() pour prÃ©senter un Ã©chantillon du rÃ©sultat. Notez la ligne comprenant la fonction mutate, que lâ€™on verra plus loin. Cette fonction ajoute une colonne au tableau. Dans ce cas-ci, jâ€™ajoute une colonne constituÃ©e dâ€™une sÃ©quence de nombres allant de 1 au nombre de lignes du tableau (il y en a 90). Cet identifiant unique pour chaque ligne permettra de reconstituer par la suite le tableau initial.\n\nchicoute_long &lt;- chicoute %&gt;%\n  select(CodeTourbiere, N_pourc, P_pourc, K_pourc) %&gt;%\n  mutate(ID = 1:nrow(.)) %&gt;% # mutate ajoute une colonne au tableau\n  pivot_longer(cols = contains(\"pourc\"), names_to = \"nutrient\", values_to = \"concentration\")\nchicoute_long %&gt;% slice_head(n = 10)\n\n# A tibble: 10 Ã— 4\n   CodeTourbiere    ID nutrient concentration\n   &lt;chr&gt;         &lt;int&gt; &lt;chr&gt;            &lt;dbl&gt;\n 1 BEAU              1 N_pourc         1.72  \n 2 BEAU              1 P_pourc         0.108 \n 3 BEAU              1 K_pourc         1.21  \n 4 BEAU              2 N_pourc         2.18  \n 5 BEAU              2 P_pourc         0.0985\n 6 BEAU              2 K_pourc         1.22  \n 7 BEAU              3 N_pourc         2.12  \n 8 BEAU              3 P_pourc         0.0708\n 9 BEAU              3 K_pourc         1.05  \n10 BEAU              4 N_pourc         1.95  \n\n\nLâ€™opÃ©ration inverse est pivot_wider(), avec laquelle nous sÃ©lectionnons une colonne spÃ©cifiant les nouvelles colonnes Ã  construire (names_from) ainsi que les valeurs Ã  placer dans ces colonnes (values_from).\n\nchicoute_large &lt;- chicoute_long %&gt;%\n  pivot_wider(names_from = nutrient, values_from = concentration)\nchicoute_large %&gt;% slice_head(n = 10)\n\n# A tibble: 10 Ã— 5\n   CodeTourbiere    ID N_pourc P_pourc K_pourc\n   &lt;chr&gt;         &lt;int&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n 1 BEAU              1    1.72  0.108    1.21 \n 2 BEAU              2    2.18  0.0985   1.22 \n 3 BEAU              3    2.12  0.0708   1.05 \n 4 BEAU              4    1.95  0.0909   1.19 \n 5 BEAU              5    2.04  0.115    0.947\n 6 BP                6    2.13  0.151    0.729\n 7 BP                7    2.06  0.162    0.824\n 8 BP                8    1.77  0.166    0.778\n 9 BP                9    2.16  0.156    0.754\n10 BP               10    2.14  0.153    0.648\n\n\n\n\n3.5.4 Combiner des tableaux\nNous avons introduit plus haut la notion de base de donnÃ©es. Nous voudrions peut-Ãªtre utiliser le code des tourbiÃ¨res pour inclure leur nom, le type dâ€™essai menÃ© Ã  ces tourbiÃ¨res, etc. Importons dâ€™abord le tableau des noms liÃ©s aux codes.\n\ntourbieres &lt;- read_csv2(\"data/chicoute_tourbieres.csv\")\n\nâ„¹ Using \"','\" as decimal and \"'.'\" as grouping mark. Use `read_delim()` for more control.\n\n\nRows: 11 Columns: 4\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \";\"\nchr (4): Tourbiere, CodeTourbiere, Type, TypeCulture\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ntourbieres\n\n# A tibble: 11 Ã— 4\n   Tourbiere               CodeTourbiere Type        TypeCulture\n   &lt;chr&gt;                   &lt;chr&gt;         &lt;chr&gt;       &lt;chr&gt;      \n 1 Beaulieu                BEAU          calibration naturel    \n 2 Brador Path             BP            calibration naturel    \n 3 Lichen (BS2E)           2             validation  cultive sec\n 4 Mannys Brook            MB            calibration naturel    \n 5 Middle Bay Road         MR            calibration naturel    \n 6 North Est of Smelt Pond NESP          calibration naturel    \n 7 North of Blue Moon      NBM           calibration naturel    \n 8 South of Smelt Pond     SSP           calibration naturel    \n 9 Sphaigne (BS2F)         BS2           validation  cultive sec\n10 Sphaigne (BS2F)         1             calibration naturel    \n11 West of Trout Pond      WTP           calibration naturel    \n\n\nNotre information est organisÃ©e en deux tableaux, liÃ©s par la colonne CodeTourbiere. Comment fusionner lâ€™information pour quâ€™elle puisse Ãªtre utilisÃ©e dans son ensemble? La fonction left_join effectue cette opÃ©ration typique avec les bases de donnÃ©es.\n\nchicoute_merge &lt;- left_join(x = chicoute, y = tourbieres, by = \"CodeTourbiere\")\n# ou bien chicoute %&gt;% left_join(y = tourbieres, by = \"CodeTourbiere\")\nchicoute_merge %&gt;% slice_head(n = 4)\n\n# A tibble: 4 Ã— 34\n     ID CodeTourbiere Ordre  Site Traitement DemiParcelle SousTraitement\n  &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;        &lt;chr&gt;         \n1     1 BEAU          A         1 &lt;NA&gt;       &lt;NA&gt;         &lt;NA&gt;          \n2     2 BEAU          A         2 &lt;NA&gt;       &lt;NA&gt;         &lt;NA&gt;          \n3     3 BEAU          A         3 &lt;NA&gt;       &lt;NA&gt;         &lt;NA&gt;          \n4     4 BEAU          A         4 &lt;NA&gt;       &lt;NA&gt;         &lt;NA&gt;          \n# â„¹ 27 more variables: Latitude_m &lt;dbl&gt;, Longitude_m &lt;dbl&gt;,\n#   Rendement_g_5m2 &lt;dbl&gt;, TotalRamet_nombre_m2 &lt;dbl&gt;,\n#   TotalVegetatif_nombre_m2 &lt;dbl&gt;, TotalFloral_nombre_m2 &lt;dbl&gt;,\n#   TotalMale_nombre_m2 &lt;dbl&gt;, TotalFemelle_nombre_m2 &lt;dbl&gt;,\n#   FemelleFruit_nombre_m2 &lt;dbl&gt;, FemelleAvorte_nombre_m2 &lt;dbl&gt;,\n#   SterileFleur_nombre_m2 &lt;dbl&gt;, C_pourc &lt;dbl&gt;, N_pourc &lt;dbl&gt;, P_pourc &lt;dbl&gt;,\n#   K_pourc &lt;dbl&gt;, Ca_pourc &lt;dbl&gt;, Mg_pourc &lt;dbl&gt;, S_pourc &lt;dbl&gt;, â€¦\n\n\nDâ€™autres types de jointures sont possibles, et dÃ©crites en dÃ©tails dans la documentation.\nGarrick Aden-Buie a prÃ©parÃ© de jolies animations pour dÃ©crire les diffÃ©rents types de jointures.\nleft_join(x, y) colle y Ã  x seulement ce qui dans y correspond Ã  ce que lâ€™on trouve dans x.\n\nright_join(x, y) colle y Ã  x seulement ce qui dans x correspond Ã  ce que lâ€™on trouve dans y.\n\ninner_join(x, y) colle x et y en excluant les lignes oÃ¹ au moins une variable de jointure est absente dans x et y.\n\nfull_join(x, y)garde toutes les lignes et les colonnes de x et y.\n\n\n\n3.5.5 OpÃ©rations sur les tableaux\nLes tableaux peuvent Ãªtre segmentÃ©s en Ã©lÃ©ments sur lesquels on calculera ce qui nous chante.\nOn pourrait vouloir obtenir :\n\nla somme avec la function sum()\nla moyenne avec la function mean() ou la mÃ©diane avec la fonction median()\nlâ€™Ã©cart-type avec la function sd()\nles maximum et minimum avec les fonctions min() et max()\nun dÃ©compte dâ€™occurrence avec la fonction n() ou count()\n\nPar exemple,\n\nmean(chicoute$Rendement_g_5m2, na.rm = TRUE)\n\n[1] 13.32851\n\n\nEn mode classique, pour effectuer des opÃ©rations sur des tableaux, on utilisera la fonction apply(). Cette fonction prend, comme arguments, le tableau, lâ€™axe (opÃ©ration par ligne = 1, opÃ©ration par colonne = 2), puis la fonction Ã  appliquer.\n\napply(chicoute %&gt;% select(contains(\"pourc\")), 2, mean)\n\n     C_pourc      N_pourc      P_pourc      K_pourc     Ca_pourc     Mg_pourc \n5.027911e+01 2.199411e+00 1.388959e-01 8.887000e-01 3.884391e-01 4.980142e-01 \n     S_pourc      B_pourc     Cu_pourc     Zn_pourc     Mn_pourc     Fe_pourc \n1.347177e-01 3.090922e-03 4.089891e-04 6.662155e-03 3.345239e-02 1.514885e-02 \n    Al_pourc \n2.694979e-03 \n\n\nLes opÃ©rations peuvent aussi Ãªtre effectuÃ©es par ligne, par exemple une somme (je garde seulement les 10 premiers rÃ©sultats).\n\napply(chicoute %&gt;% select(contains(\"pourc\")), 1, sum)[1:10]\n\n [1] 55.64299 55.76767 54.78856 55.84453 57.89671 55.53603 55.62526 55.10991\n [9] 55.06295 55.16774\n\n\nLa fonction Ã  appliquer peut Ãªtre personnalisÃ©e, par exemple:\n\napply(\n  chicoute %&gt;% select(contains(\"pourc\")), 2,\n  function(x) (prod(x))^(1 / length(x))\n)\n\n     C_pourc      N_pourc      P_pourc      K_pourc     Ca_pourc     Mg_pourc \n50.253429104  2.165246915  0.133754530  0.846193827  0.376192724  0.491763884 \n     S_pourc      B_pourc     Cu_pourc     Zn_pourc     Mn_pourc     Fe_pourc \n 0.129900753  0.003014675  0.000000000  0.006408775  0.024140327  0.014351745 \n    Al_pourc \n 0.002450982 \n\n\nVous reconnaissez cette fonction? Câ€™Ã©tait la moyenne gÃ©omÃ©trique (la fonction prod() Ã©tant le produit dâ€™un vecteur).\nEn mode tidyverse, on aura besoin principalement des fonction suivantes:\n\ngroup_by() pour effectuer des opÃ©rations par groupe, lâ€™opÃ©ration group_by() sÃ©pare le tableau en plusieurs petits tableaux, en attendant de les recombiner. Câ€™est un peu lâ€™Ã©quivalent des facettes avec le module de visualisation ggplot2, que nous explorons au chapitreÂ 4.\nsummarise() pour rÃ©duire plusieurs valeurs en une seule, il applique un calcul sur le tableau ou sâ€™il y a lieu sur chaque petit tableau segmentÃ©. Il en existe quelques variantes.\n\nsummarise_all() applique la fonction Ã  toutes les colonnes\nsummarise_at() applique la fonction aux colonnes spÃ©cifiÃ©es\nsummarise_if() applique la fonction aux colonnes qui ressortent comme TRUE selon une opÃ©ration boolÃ©enne\n\nmutate() pour ajouter une nouvelle colonne\n\nSi lâ€™on dÃ©sire ajouter une colonne Ã  un tableau, par exemple le sommaire calculÃ© avec summarise(). Ã€ lâ€™inverse, la fonction transmute() retournera seulement le rÃ©sultat, sans le tableau Ã  partir duquel il a Ã©tÃ© calculÃ©. De mÃªme que summarise(), mutate() et transmute() possÃ¨dent leurs Ã©quivalents _all(), _at() et _if().\n\narrange() pour rÃ©ordonner le tableau\n\nCette fonction est parfois utile lors de la mise en page de tableaux ou de graphiques. Il ne sâ€™agit pas dâ€™une opÃ©ration sur un tableau, mais plutÃ´t un changement dâ€™affichage en changeant lâ€™ordre dâ€™apparition des donnÃ©es.\n\n\nCes opÃ©rations sont dÃ©crites dans lâ€™aide-mÃ©moire Data Transformation Cheat Sheet (FigureÂ 3.5).\n\n\n\n\n\nFigureÂ 3.5: Aide-mÃ©moire pour la transformation des donnÃ©es, https://rstudio.github.io/cheatsheets/data-transformation.pdf\n\n\n\n\nPour effectuer des statistiques par colonne, on utilisera summarise pour des statistiques effectuÃ©es sur une seule colonne. summarise peut prendre le nombre dÃ©sirÃ© de statistiques dont la sortie est un scalaire.\n\nchicoute %&gt;%\n  summarise(\n    moyenne = mean(TotalFloral_nombre_m2, na.rm = TRUE),\n    ecart_type = sd(TotalFloral_nombre_m2, na.rm = TRUE)\n  )\n\n# A tibble: 1 Ã— 2\n  moyenne ecart_type\n    &lt;dbl&gt;      &lt;dbl&gt;\n1    52.1       40.4\n\n\nSi lâ€™on dÃ©sire un sommaire sur toutes les variables sÃ©lectionnÃ©es, on utilisera summarise_all(). Pour spÃ©cifier que lâ€™on dÃ©sire la moyenne et lâ€™Ã©cart-type, on inscrit les noms des fonctions dans list().\n\nchicoute %&gt;%\n  select(contains(\"pourc\")) %&gt;%\n  summarise_all(list(mean, sd))\n\n# A tibble: 1 Ã— 26\n  C_pourc_fn1 N_pourc_fn1 P_pourc_fn1 K_pourc_fn1 Ca_pourc_fn1 Mg_pourc_fn1\n        &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;\n1        50.3        2.20       0.139       0.889        0.388        0.498\n# â„¹ 20 more variables: S_pourc_fn1 &lt;dbl&gt;, B_pourc_fn1 &lt;dbl&gt;,\n#   Cu_pourc_fn1 &lt;dbl&gt;, Zn_pourc_fn1 &lt;dbl&gt;, Mn_pourc_fn1 &lt;dbl&gt;,\n#   Fe_pourc_fn1 &lt;dbl&gt;, Al_pourc_fn1 &lt;dbl&gt;, C_pourc_fn2 &lt;dbl&gt;,\n#   N_pourc_fn2 &lt;dbl&gt;, P_pourc_fn2 &lt;dbl&gt;, K_pourc_fn2 &lt;dbl&gt;,\n#   Ca_pourc_fn2 &lt;dbl&gt;, Mg_pourc_fn2 &lt;dbl&gt;, S_pourc_fn2 &lt;dbl&gt;,\n#   B_pourc_fn2 &lt;dbl&gt;, Cu_pourc_fn2 &lt;dbl&gt;, Zn_pourc_fn2 &lt;dbl&gt;,\n#   Mn_pourc_fn2 &lt;dbl&gt;, Fe_pourc_fn2 &lt;dbl&gt;, Al_pourc_fn2 &lt;dbl&gt;\n\n\nOn utilisera group_by() pour segmenter le tableau, et ainsi obtenir des statistiques pour chaque groupe.\n\nchicoute %&gt;%\n  group_by(CodeTourbiere) %&gt;%\n  summarise(\n    moyenne = mean(TotalFloral_nombre_m2, na.rm = TRUE),\n    ecart_type = sd(TotalFloral_nombre_m2, na.rm = TRUE)\n  )\n\n# A tibble: 12 Ã— 3\n   CodeTourbiere moyenne ecart_type\n   &lt;chr&gt;           &lt;dbl&gt;      &lt;dbl&gt;\n 1 1                72.1      32.7 \n 2 2                37.1      32.9 \n 3 BEAU            149.       53.2 \n 4 BP               60.4      30.6 \n 5 BS2              27.2      15.5 \n 6 MB               64.7      40.8 \n 7 MR               35.1      10.5 \n 8 NBM              35.1      16.6 \n 9 NESP             21.4       4.88\n10 NTP              47.6      15.9 \n11 SSP              25.7      11.1 \n12 WTP              50.2      28.3 \n\n\nDans le cas de summarise_all, les rÃ©sultats sâ€™affichent de la mÃªme maniÃ¨re.\n\nchicoute %&gt;%\n  group_by(CodeTourbiere) %&gt;%\n  select(N_pourc, P_pourc, K_pourc) %&gt;%\n  summarise_all(list(mean, sd))\n\nAdding missing grouping variables: `CodeTourbiere`\n\n\n# A tibble: 12 Ã— 7\n   CodeTourbiere N_pourc_fn1 P_pourc_fn1 K_pourc_fn1 N_pourc_fn2 P_pourc_fn2\n   &lt;chr&gt;               &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 1                    2.26      0.156        0.880      0.250      0.0193 \n 2 2                    2.76      0.181        1.12       0.178      0.0283 \n 3 BEAU                 2.00      0.0967       1.12       0.179      0.0172 \n 4 BP                   2.05      0.158        0.747      0.161      0.00625\n 5 BS2                  2.08      0.103        1.12       0.420      0.0218 \n 6 MB                   2.15      0.109        0.675      0.114      0.0165 \n 7 MR                   1.99      0.127        0.830      0.0802     0.0131 \n 8 NBM                  2.01      0.127        0.854      0.310      0.0202 \n 9 NESP                 1.76      0.135        0.945      0.149      0.0108 \n10 NTP                  1.83      0.0873       0.402      0.166      0.0103 \n11 SSP                  1.83      0.130        0.700      0.160      0.00383\n12 WTP                  1.79      0.0811       0.578      0.132      0.00587\n# â„¹ 1 more variable: K_pourc_fn2 &lt;dbl&gt;\n\n\nPour obtenir des statistiques Ã  chaque ligne, mieux vaut utiliser apply(), tel que vu prÃ©cÃ©demment. Le point, ., reprÃ©sente le tableau dans une fonction qui nâ€™a pas Ã©tÃ© conÃ§ue pour fonctionner de facto avec dplyr.\n\nchicoute %&gt;%\n  select(contains(\"pourc\")) %&gt;%\n  apply(., 1, sum)\n\n [1] 55.64299 55.76767 54.78856 55.84453 57.89671 55.53603 55.62526 55.10991\n [9] 55.06295 55.16774 56.41123 55.47917 55.43537 55.79175 55.44561 54.85448\n[17] 54.34262 55.03075 54.40533 51.89319 54.70172 54.62176 54.30250 53.86976\n[25] 53.44731 53.86244 52.43280 54.34978 53.96756 51.46672 55.44267 54.70350\n[33] 55.30711 56.16200 56.64710 55.95499 54.76370 54.32775 54.95419 53.37094\n[41] 53.07855 53.04541 52.09520 52.40456 51.92376 53.33248 56.56405 56.35004\n[49] 56.27185 55.56986 53.81654 55.39638 55.51961 54.88098 54.74774 51.08921\n[57] 51.31462 53.46819 53.15640 52.82020 57.78038 57.94636 56.65558 56.28845\n[65] 55.54463 56.51751 55.36497 56.00594 55.64247 56.56967 56.81674 55.87070\n[73] 55.72308 56.14116 56.42611 55.35650 54.90469 54.03674 53.42991 53.99334\n[81] 53.09085 53.23222 53.28212 53.63192 53.48102 52.31131 51.72026 51.10534\n[89] 51.49055 51.59297\n\n\nPrenons ce tableau des espÃ¨ces menacÃ©es issu de lâ€™Union internationale pour la conservation de la nature distribuÃ© par lâ€™OCDE.\n\nlibrary(\"tidyverse\")\nespeces_menacees &lt;- read_csv(\"data/WILD_LIFE_14012020030114795.csv\")\n\nNous exÃ©cutons le pipeline suivant.\n\nespeces_menacees %&gt;%\n  dplyr::filter(IUCN == \"CRITICAL\", SPEC == \"VASCULAR_PLANT\") %&gt;%\n  dplyr::select(Country, Value) %&gt;%\n  dplyr::group_by(Country) %&gt;%\n  dplyr::summarise(n_critical_plants = sum(Value)) %&gt;%\n  dplyr::arrange(desc(n_critical_plants)) %&gt;%\n  dplyr::slice_head(n = 10)\n\n# A tibble: 10 Ã— 2\n   Country         n_critical_plants\n   &lt;chr&gt;                       &lt;dbl&gt;\n 1 United States                1222\n 2 Japan                         525\n 3 Canada                        315\n 4 Czech Republic                284\n 5 Spain                         271\n 6 Belgium                       253\n 7 Austria                       172\n 8 Slovak Republic               155\n 9 Australia                     148\n10 Italy                         128\n\n\nCe pipeline consiste Ã :\nprendre le tableau especes_menacees, puis\n  \nfiltrer pour n'obtenir que les espÃ¨ces critiques dans la catÃ©gorie des plantes vasculaires, puis\n  \nsÃ©lectionner les colonnes des pays et des valeurs (nombre d'espÃ¨ces), puis\n\nsegmenter le tableau en plusieurs tableaux selon le pays, puis\n\nappliquer la fonction sum pour chacun de ces petits tableaux (et recombiner ces sommaires), puis\n\ntrier les pays en nombre dÃ©croissant de dÃ©compte d'espÃ¨ces, puis\n\nafficher le top 10\nNotez quâ€™il aurait aussi Ã©tÃ© possible dâ€™utiliser la fonction dplyr::slice_max(n_critical_plants, n = 10) pour afficher directement le top 10, sans faire le tri prÃ©alable.\n\n\n3.5.6 Exemple (difficile)\nPour revenir Ã  notre tableau chicoute, imaginez que vous aviez une station mÃ©tÃ©o (station_A) situÃ©e aux coordonnÃ©es (490640, 5702453) et que vous dÃ©siriez calculer la distance entre lâ€™observation et la station. Prenez du temps pour rÃ©flÃ©chir Ã  la maniÃ¨re dont vous procÃ©derezâ€¦\n\nOn pourra crÃ©er une fonction qui mesure la distance entre un point x, y et les coordonnÃ©es de la station Aâ€¦\n\ndist_station_A &lt;- function(x, y) {\n  return(sqrt((x - 490640)^2 + (y - 5702453)^2))\n}\n\nâ€¦ puis ajouter une colonne avec mutate grÃ¢ce Ã  une fonction prenant les arguments x et y spÃ©cifiÃ©s.\n\nchicoute %&gt;%\n  mutate(dist = dist_station_A(x = Longitude_m, y = Latitude_m)) %&gt;%\n  select(ID, CodeTourbiere, Longitude_m, Latitude_m, dist) %&gt;%\n  slice_head(n = 10)\n\n# A tibble: 10 Ã— 5\n      ID CodeTourbiere Longitude_m Latitude_m    dist\n   &lt;dbl&gt; &lt;chr&gt;               &lt;dbl&gt;      &lt;dbl&gt;   &lt;dbl&gt;\n 1     1 BEAU               490627    5702454   13.0 \n 2     2 BEAU               490634    5702452    6.08\n 3     3 BEAU               490638    5702461    8.25\n 4     4 BEAU               490647    5702453    7   \n 5     5 BEAU               490654    5702445   16.1 \n 6     6 BP                 484865    5706394 6992.  \n 7     7 BP                 484054    5706307 7631.  \n 8     8 BP                 484742    5702280 5901.  \n 9     9 BP                 484761    5706324 7039.  \n10    10 BP                 484780    5706364 7045.  \n\n\nNous pourrions procÃ©der de la mÃªme maniÃ¨re pour fusionner des donnÃ©es climatiques. Le tableau chicoute ne possÃ¨de pas dâ€™indicateurs climatiques, mais il est possible de les soutirer de stations mÃ©tÃ©o placÃ©es prÃ¨s des sites. Ces donnÃ©es ne sont pas disponibles pour le tableau de la chicoutÃ©, alors jâ€™utiliserai des donnÃ©es fictives pour lâ€™exemple.\nVoici ce qui pourrait Ãªtre fait.\n\nCrÃ©er un tableau des stations mÃ©tÃ©o ainsi que des indices mÃ©tÃ©orologiques associÃ©s Ã  ces stations.\nLier chaque site Ã  une station (Ã  la main oÃ¹ selon la plus petite distance entre le site et la station).\nFusionner les indices climatiques aux sites, puis les sites aux mesures de rendement.\n\nCes opÃ©rations demandent habituellement du tÃ¢tonnement. Il serait surprenant que mÃªme une personne expÃ©rimentÃ©e soit en mesure de compiler ces opÃ©rations sans obtenir de message dâ€™erreur, et retravailler jusquâ€™Ã  obtenir le rÃ©sultat souhaitÃ©. Lâ€™objectif de cette section est de vous prÃ©senter un flux de travail que vous pourriez Ãªtre amenÃ©s Ã  effectuer et de fournir quelques Ã©lÃ©ments nouveaux pour mener Ã  bien une opÃ©ration. Il peut Ãªtre frustrant de ne pas saisir toutes les opÃ©rations: passez Ã  travers cette section sans jugement. Si vous devez vous frotter Ã  un problÃ¨me semblable, vous saurez que vous trouverez dans ce manuel une recette intÃ©ressante.\n\nmes_stations &lt;- data.frame(\n  Station = c(\"A\", \"B\", \"C\"),\n  Longitude_m = c(490640, 484870, 485929),\n  Latitude_m = c(5702453, 5701870, 5696421),\n  t_moy_C = c(13.8, 18.2, 16.30),\n  prec_tot_mm = c(687, 714, 732)\n)\nmes_stations\n\n  Station Longitude_m Latitude_m t_moy_C prec_tot_mm\n1       A      490640    5702453    13.8         687\n2       B      484870    5701870    18.2         714\n3       C      485929    5696421    16.3         732\n\n\nLa fonction suivante calcule la distance entre des coordonnÃ©es x et y et chaque station dâ€™un tableau de stations, puis retourne le nom de la station dont la distance est la moindre.\n\ndist_station &lt;- function(x, y, stations_df) {\n  # stations est le tableau des stations Ã  trois colonnes\n  # 1iere: nom de la station\n  # 2ieme: longitude\n  # 3ieme: latitude\n  distance &lt;- c()\n  for (i in 1:nrow(stations_df)) {\n    distance[i] &lt;- sqrt((x - stations_df[i, 2])^2 + (y - stations_df[i, 3])^2)\n  }\n  nom_station &lt;- as.character(stations_df$Station[which.min(distance)])\n  return(nom_station)\n}\n\nTestons la fonction avec des coordonnÃ©es.\n\ndist_station(x = 459875, y = 5701988, stations_df = mes_stations)\n\n[1] \"B\"\n\n\nNous appliquons cette fonction Ã  toutes les lignes du tableau, puis en retournons un Ã©chantillon.\n\nchicoute %&gt;%\n  rowwise() %&gt;%\n  mutate(Station = dist_station(x = Longitude_m, y = Latitude_m, stations_df = mes_stations)) %&gt;%\n  select(ID, CodeTourbiere, Longitude_m, Latitude_m, Station) %&gt;%\n  slice_head(n = 10)\n\n# A tibble: 90 Ã— 5\n# Rowwise: \n      ID CodeTourbiere Longitude_m Latitude_m Station\n   &lt;dbl&gt; &lt;chr&gt;               &lt;dbl&gt;      &lt;dbl&gt; &lt;chr&gt;  \n 1     1 BEAU               490627    5702454 A      \n 2     2 BEAU               490634    5702452 A      \n 3     3 BEAU               490638    5702461 A      \n 4     4 BEAU               490647    5702453 A      \n 5     5 BEAU               490654    5702445 A      \n 6     6 BP                 484865    5706394 B      \n 7     7 BP                 484054    5706307 B      \n 8     8 BP                 484742    5702280 B      \n 9     9 BP                 484761    5706324 B      \n10    10 BP                 484780    5706364 B      \n# â„¹ 80 more rows\n\n\nCela semble fonctionner. On peut y ajouter un left_join() pour joindre les donnÃ©es mÃ©tÃ©o au tableau principal.\n\nchicoute_weather &lt;- chicoute %&gt;%\n  rowwise() %&gt;%\n  mutate(Station = dist_station(x = Longitude_m, y = Latitude_m, stations_df = mes_stations)) %&gt;%\n  left_join(y = mes_stations, by = \"Station\")\nchicoute_weather %&gt;% slice_head(n = 10)\n\n# A tibble: 90 Ã— 36\n# Rowwise: \n      ID CodeTourbiere Ordre  Site Traitement DemiParcelle SousTraitement\n   &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;        &lt;chr&gt;         \n 1     1 BEAU          A         1 &lt;NA&gt;       &lt;NA&gt;         &lt;NA&gt;          \n 2     2 BEAU          A         2 &lt;NA&gt;       &lt;NA&gt;         &lt;NA&gt;          \n 3     3 BEAU          A         3 &lt;NA&gt;       &lt;NA&gt;         &lt;NA&gt;          \n 4     4 BEAU          A         4 &lt;NA&gt;       &lt;NA&gt;         &lt;NA&gt;          \n 5     5 BEAU          A         5 &lt;NA&gt;       &lt;NA&gt;         &lt;NA&gt;          \n 6     6 BP            H         1 &lt;NA&gt;       &lt;NA&gt;         &lt;NA&gt;          \n 7     7 BP            H         2 &lt;NA&gt;       &lt;NA&gt;         &lt;NA&gt;          \n 8     8 BP            H         3 &lt;NA&gt;       &lt;NA&gt;         &lt;NA&gt;          \n 9     9 BP            H         4 &lt;NA&gt;       &lt;NA&gt;         &lt;NA&gt;          \n10    10 BP            H         5 &lt;NA&gt;       &lt;NA&gt;         &lt;NA&gt;          \n# â„¹ 80 more rows\n# â„¹ 29 more variables: Latitude_m.x &lt;dbl&gt;, Longitude_m.x &lt;dbl&gt;,\n#   Rendement_g_5m2 &lt;dbl&gt;, TotalRamet_nombre_m2 &lt;dbl&gt;,\n#   TotalVegetatif_nombre_m2 &lt;dbl&gt;, TotalFloral_nombre_m2 &lt;dbl&gt;,\n#   TotalMale_nombre_m2 &lt;dbl&gt;, TotalFemelle_nombre_m2 &lt;dbl&gt;,\n#   FemelleFruit_nombre_m2 &lt;dbl&gt;, FemelleAvorte_nombre_m2 &lt;dbl&gt;,\n#   SterileFleur_nombre_m2 &lt;dbl&gt;, C_pourc &lt;dbl&gt;, N_pourc &lt;dbl&gt;, â€¦\n\n\n\n\n3.5.7 Exporter un tableau\nSimplement avec write_csv().\n\nwrite_csv(chicoute_weather, \"data/chicoute_weather.csv\")\n\n\n\n3.5.8 Aller plus loin dans le tidyverse\nLe livre R for data science (2e), de Hadley Wickham et Garrett Grolemund (couverture Ã  la FigureÂ 3.6), est un incontournable.\n\n\n\n\n\nFigureÂ 3.6: Couverture du libre de Hadley Wickham, Mine Ã‡etinkaya-Rundel et Garrett Grolemund, Source: https://r4ds.hadley.nz/"
  },
  {
    "objectID": "03-tableaux.html#rÃ©fÃ©rences",
    "href": "03-tableaux.html#rÃ©fÃ©rences",
    "title": "3Â  Organisation des donnÃ©es et opÃ©rations sur des tableaux",
    "section": "3.6 RÃ©fÃ©rences",
    "text": "3.6 RÃ©fÃ©rences\nParent L.E., Parent, S.Ã‰., Herbert-Gentile, V., Naess, K. et Lapointe, L. 2013. Mineral Balance Plasticity of Cloudberry (Rubus chamaemorus) in Quebec-Labrador Bogs. American Journal of Plant Sciences, 4, 1508-1520. DOI: 10.4236/ajps.2013.47183"
  },
  {
    "objectID": "04-visualisation.html",
    "href": "04-visualisation.html",
    "title": "4Â  Visualisation",
    "section": "",
    "text": "Ã€ venir"
  },
  {
    "objectID": "05-github.html",
    "href": "05-github.html",
    "title": "5Â  Science ouverte et reproductibilitÃ©",
    "section": "",
    "text": "Ã€ venir"
  },
  {
    "objectID": "06-python.html",
    "href": "06-python.html",
    "title": "6Â  Introduction Ã  Python",
    "section": "",
    "text": "Il peut arriver que, pour une raison ou une autre, vous puissiez bÃ©nÃ©ficier de travailler avec Python. Par exemple, si vous travaillez en gÃ©omatique avec QGIS ou mÃªme ArcGIS, Python peut Ãªtre utilisÃ© pour faire vos manipulations de donnÃ©es et vos analyses spatiales. Le fonctionnement de Python ressemble assez Ã  R et vous remarquerez quâ€™une fois la premiÃ¨re barriÃ¨re de programmation franchie, les langages subsÃ©quents sont beaucoup plus faciles Ã  assimiler.\nLâ€™auteur de ce manuel, Essi Parent, a publiÃ© lâ€™automne dernier une introduction au calcul numÃ©rique avec Python. Pour le consulter, vous pouvez soit crÃ©er une fork sur votre github et cloner le rÃ©pertoire, ou alors consulter les fichiers directement dans le navigateur. Il est possible que la prÃ©sente section soit bonifiÃ©e au cours de la session, mais Ã  premiÃ¨re vue le rÃ©pertoire de Essi semble concis et bien fait. Sinon, comme pour R, il existe plusieurs bons manuels, en anglais toutefois. Rappelez-vous que cette section est facultative; vous pourrez y revenir dans le futur lorsque le besoin se prÃ©sentera!"
  },
  {
    "objectID": "07a-biostats.html",
    "href": "07a-biostats.html",
    "title": "7Â  Biostatistiques",
    "section": "",
    "text": "Ã€ venir"
  },
  {
    "objectID": "07b-bayes.html",
    "href": "07b-bayes.html",
    "title": "8Â  Introduction Ã  lâ€™analyse bayÃ©sienne en Ã©cologie",
    "section": "",
    "text": "Ã€ venir"
  },
  {
    "objectID": "08-regression.html",
    "href": "08-regression.html",
    "title": "9Â  RÃ©gression",
    "section": "",
    "text": "Ã€ venir"
  },
  {
    "objectID": "09-explorer.html",
    "href": "09-explorer.html",
    "title": "10Â  Explorer R",
    "section": "",
    "text": "Ã€ venir"
  },
  {
    "objectID": "10-ordination.html",
    "href": "10-ordination.html",
    "title": "11Â  Association, partitionnement et ordination",
    "section": "",
    "text": "Ã€ venir"
  },
  {
    "objectID": "11-imputation.html",
    "href": "11-imputation.html",
    "title": "12Â  DÃ©tection de valeurs aberrantes et imputation de donnÃ©es manquantes",
    "section": "",
    "text": "Ã€ venir"
  },
  {
    "objectID": "12-series-temporelles.html",
    "href": "12-series-temporelles.html",
    "title": "13Â  Les sÃ©ries temporelles",
    "section": "",
    "text": "Ã€ venir"
  },
  {
    "objectID": "13-autoapprentissage.html",
    "href": "13-autoapprentissage.html",
    "title": "14Â  Introduction Ã  lâ€™autoapprentissage",
    "section": "",
    "text": "Ã€ venir"
  },
  {
    "objectID": "14-donnees-spatiales.html",
    "href": "14-donnees-spatiales.html",
    "title": "15Â  Les donnÃ©es gÃ©ospatiales",
    "section": "",
    "text": "Ã€ venir"
  },
  {
    "objectID": "15-modelisation.html",
    "href": "15-modelisation.html",
    "title": "16Â  ModÃ©lisation de mÃ©canismes Ã©cologiques",
    "section": "",
    "text": "Ã€ venir"
  }
]