# Les données géospatiales {#sec-geo}

---

️\ **Objectifs spécifiques**:

À la fin de ce chapitre, vous

- saurez cartographier des données géoréférencées avec ggplot
- serez en mesure d'effectuer un autoapprentissage spatial
- saurez utiliser R comme outil d'analyse spatiale (donnée associées à des points, lignes, polygones et rasters)

---

## Les données spatiales

Des données associées à un endroit sont spatiales. Puisque ce cours ne traite pas d'écologie exoplanétaire, nous traiterons en particulier de données *géo*spatiales, mot que l'on utilise pour désigner des données avec référence spatiale sur la planète Terre.

Lorsque nous avons abordé les séries temporelles, j'ai pris pour acquis que nous utilisions le calendrier grégorien comme référence temporelle. Les données géospatiales, quant à elles, sont souvent exprimées en termes d'angles donnant une position à la surface d'une référence dont la forme est un ellipsoide de révolution (le système géodésique): la longitude décrivant l'angle de part et d'autre (entre 0° et 180° Ouest ou Est) du méridien de référence (le *premier méridien*, près de Greenwich) et la latitude décrivant l'angle entre l'équateur et l'un des pôles (entre 0° et 90° Nord ou Sud). Les angles sont parfois exprimées sous forme `degré° minute' seconde'' Sens cardinal`, par exemple `46° 53' 21.659'' S`. Toutefois, il est plus commun (et plus pratique) d'exprimer les angles de manière décimale, accompagnée d'un signe pour indiquer le sens cardinal (par convention positif au Nord et à l'Est). Par exemple, on exprimerait `46° 53' 21.659'' S` sous forme décimale par les opérations suivantes.

$$
secondes = \frac{21.659''}{3600'' \cdot °^{-1}} = 0.00602°
$$

$$
minutes = \frac{53'}{60' \cdot °^{-1}} = 0.883°
$$

$$
- \left( 46° + 0.883° + 0.00602° \right) = -46.889°
$$

La référence de l'altitude est généralement donnée par rapport à un géoïde, qui est une élévation théorique du niveau de la mer ainsi qu'une direction de la gravité évaluée sur toute la surface du globe.

Toutefois, les angles ne sont pas pratiques pour évaluer des distances, ce que l'on fera bien mieux sur une carte. Pour présenter la Terre sous forme de carte, on crée des représentations applaties du globe sous forme de carte avec l'aide d'équations de projection.

Or, il existe différents systèmes géodésiques, différents géoides et de nombreuses manières de calculer les projections. Ainsi, il est important de spécifier les références utilisées lorsque l'on donne dans la précision. Pour cette séance, je prendrai pour acquis que vous possédez certaines bases en positionnement, qui sont par ailleurs essentielles pour pratiquer adéquatement un métier scientifique.

```{r}
#| label: spat-load-tidyverse
#| message: false
#| warning: false

library("tidyverse")
```

Dans ce chapitre, j'utiliserai notamment comme exemple d'application des données météorologiques soutirées d'Environnement Canada grâce au module **`weathercan`**, obtenues entre les longitudes -60° et -80° et entre les latitudes 45° et 50° en mai 2018. J'ai effectué quelques opérations pour obtenir des indicateurs météo: degrés-jour (somme des degrés de température moyenne > 5 °C, `degree_days`), précipitations totales (`cumul_precip`) et indice de diversité des précipitations (plus l'indice `sdi` s'approche de 1, plus les températures sont uniformément distribuées pendant la période). Les calculs sont consignés dans le fichier `lib/12_weather-fetch.R`, mais étant donné que le téléchargement prend pas mal de temps, j'ai créé un csv. Les coordonnées se trouvent dans les colonnes de latitude (`lat`) et longitude (`lon`).

```
source("lib/12_weather-fetch.R")
```

```{r}
#| label: spat-load-weather
#| message: false

weather <- read_csv("data/12_weather.csv")
weather %>% head()
```

Dans le tableau `weather`, chaque observation est liée à un point dans l'espace. Dans ce cas, nous avons tous les outils nécessaires pour afficher nos points dans l'espace ([figure @fig-weather-ggplot1]).

```{r}
#| label: fig-weather-ggplot1
#| out-width: 100%
#| fig-align: center
#| fig-cap: "Position des stations météo du tableau `weather`"

weather %>%
  ggplot(mapping = aes(x = lon, y = lat)) +
  geom_point()
```

Si vous avez l'oeil averti, vous avez peut-être repéré le Québec, le Nouveau-Brunswick et la frontière avec les États-Unis. L'absence de repère rend néanmoins difficile l'interprétation de cette carte.

## Cartographier avec le module **`ggmap`**

Le module **`ggmap`** ajoute des couches d'images téléchargées depuis des services de cartographie en ligne. Dans cette section, nous allons utiliser le service de carte [Stamen](http://maps.stamen.com). Ces cartes sont maintenant gérées par Stadia Maps et ils est nécessaire de créer un compte d'utilisateur sur le site <https://stadiamaps.com/>. Une fois le compte a été crée, il est nécessaire d'obtenir un API qui vous donnera accès aux cartes stamen. Toutes les instructions pour utiliser ces cartes avec ggmap se trouvent [ici](https://docs.stadiamaps.com/tutorials/getting-started-in-r-with-ggmap/). La fonction `get_stadiamap()` demande une boîte de coordonnées délimitant la carte à produire, un paramètre de zoom (plus le zoom est élevé, plus la carte inclura de détails: un zoom de 2 est suffisant pour une carte du monde, mais pour l'Est du Canada, on prendra plutôt un zoom de 6 (un bon zoom est obtenu par tâtonnement) et accessoirement un type de carte.

```{r, message = FALSE}
#| label: spat-ggamp
#| message: false
library(ggmap)
library(osmdata)

east_canada <- get_stadiamap(bbox = c(left=-81, right = -59, bottom = 44, top = 51),
                             zoom = 6,
                             maptype = "stamen_terrain")
```

Pour afficher la carte, nous enchâssons notre objet dans une fonction `ggmap()`, à laquelle nous pouvons ajouter une couche.

```
ggmap(east_canada) +
  geom_point(data = weather, mapping = aes(x = lon, y = lat))
```

Une approche plus généraliste consiste à spécifier dans la fonction `ggmap()` l'argument de base utilisé pour lancer un graphique ggplot, comme à la [figure @fig-spat_weather_ggmap1]. En outre, l'utilisation de l'argument `base_layer` permet d'effectuer des facettes et d'éviter de spécifier la source des données dans toutes les couches subséquentes.

```{r}
#| label: fig-spat_weather_ggmap1
#| out-width: 100%
#| fig-align: center
#| fig-cap: "Position des stations météo du tableau `weather` superposé à une carte importée par **`ggmap`**"

ggmap(east_canada,
      base_layer = ggplot(weather, aes(x = lon, y = lat))) + 
  geom_point()
```

La carte que nous avons créée est de type `terrain`, un type d'affichage efficace mais peu approprié pour une publication visant à être imprimée. Le type `toner-lite` est davantage voué à l'impression, alors que le type `watercolor` est plus joli pour le web. Les types offerts sont listés dans la ficher d'aide `?get_stadiamap`.

```
maptype = c(stamen_terrain, stamen_toner, stamen_toner_lite, stamen_watercolor, stamen_terrain_background,
            stamen_toner_background, stamen_terrain_lines, stamen_terrain_labels, stamen_toner_lines, stamen_toner_labels)
```

## Types génériques de données spatiales

Nous avons jusqu'à présent utilisé des données spatiales attachées à un point. Ce ne sont pas les seuls.

1. **Données ponctuelles**: associées à un point. Exemple: mesure à un endroit précis.
1. **Données linéaires**: associées à une série de point. Exemple: mesure associée à une route ou une rivière.
1. **Données de polygone**: associées à une aire délimitée par des points. Exemples: Données associées à un champ, une unité administrative, un bassin versant, etc.
1. **Données raster**: associées à une grille. Exemple: une image satellite où chaque pixel est associé à un recouvrement foliaire.

L'enregistrement des données ponctuelles ne posent pas de défi particulier. Les données associées à un ligne, toutefois posent un problème d'organisation, puisqu'une ligne elle-même contient des informations sur les *coordonnées* de ses points ainsi que l'*ordre* dans lequel les points sont connectés. On pourra soit créer un tableau de données ayant une colonne où l'identifiant de la ligne est consigné, renvoyant à un autre tableau où chaque ligne décrit un point en terme d'identifiant de ligne à laquelle il appartient, ses coordonnées, ainsi que sont ordre de rattachement dans la ligne. Les informations de la ligne pourraient aussi être enchâssées dans une cellule de tableau de données, en tant que sous-tableau. Ou bien, on pourrait créer un tableau sous forme de jointure entre le tableau des données et le tableau des lignes. Un défi similaire pourrait subvenir avec des polygones, qui demandent davantage d'information étant donnée qu'ils peuvent être troués (par exemple un lac) ou séparés en différents morceaux (un archipel, par exemple). Enfin, il existe des formats de données spatiales génériques (shapefiles et geojson) ou spécialement conçus pour R (module **`sf`**), que nous couvrirons plus loin dans ce chapitre.

## Les choroplèthe

Les cartes de type *choroplèthe* se présentent sous forme de **polygones** décrits par un *groupe* et un *ordre*, dont la couleur de remplissage dépend d'une variable. Les pays, par exemple, forment des polygones.

```{r}
#| label: spat-world
#| message: false
#| warning: false

world <- map_data(map = "world") # jeu de donneés de ggplot2
head(world)
```

La fonction `map_data()` de **`ggplot2`** permet de soutirer des polygone de [certaines cartes](https://www.rdocumentation.org/packages/ggplot2/versions/3.1.0/topics/map_data). Pour les zones géographiques prédéfinies, il est préférable de soutirer les polygones désirées de données existantes plutôt que les créer soi-même. Souvent, ces polygones ne sont pas directement disponibles en R. Dans ce cas, il faudra trouver des fichiers de carte auprès de [Statistique Canada](https://www.statcan.gc.ca/fra/debut), [Données Québec](https://www.donneesquebec.ca), etc., ce que nous verrons plus loin.

```{r}
#| label: spat-load-iucn
#| message: false
#| warning: false

especes_menacees <- read_csv('data/WILD_LIFE_14012020030114795.csv')
iucn_oecd <- especes_menacees %>%
  dplyr::filter(IUCN == "THREATENED", SPEC == "MAMMAL") %>%
  dplyr::select(Country, Value) %>%
  dplyr::group_by(Country) %>% 
  dplyr::summarise(n_threatened_species = sum(Value)) %>%
  dplyr::arrange(desc(n_threatened_species))
```

Les noms des pays doivent correspondre exactement, et la colonne des pays doit porter le même nom (j'ai inspecté les vecteurs `iucn_oecd30$Country` et `unique(world$region)`).

```{r}
#| label: spat-iucn-clean

iucn_oecd <- iucn_oecd %>% 
  replace(.=="United States", "USA") %>% 
  replace(.=="Slovak Republic", "Slovakia") %>% 
  replace(.=="United Kingdom", "UK") %>% 
  dplyr::rename("region" = "Country")
```

Les espèces sont jointes au tableau contenant les polygones.

```{r}
#| label: spat-iucn-leftjoin

world_iucn <- world %>% 
  left_join(iucn_oecd, by = "region")
```

Pour le graphique de la [figure @fig-spat_iucn1], La stratégie est de créer des polygones groupés par groupes de polygones (`group = group`), dont la couleur de remplissage correspond au nombre d'espèce. J'ajoute `coord_map()` en spécifiant une projection de type Mercator (essayez `projection = "ortho"`). Le reste est de la décoration.

```{r, out.width="100%"}
#| label: fig-spat_iucn1
#| out-width: 100%
#| fig-align: center
#| fig-cap: "Nombre d'espèces en danger dans les pays de l'OCDE"

ggplot(world_iucn, aes(long, lat)) +
  geom_polygon(aes(group = group, fill = n_threatened_species),
               colour = "grey50", lwd = 0.1) +
  coord_map(projection = "mercator", xlim = c(-180, 180), ylim = c(-90, 90)) +
  scale_fill_gradient(low = "#8CBFE6", high = "#FF0099", na.value = "grey70") +
  labs(title = "Number of threatened species in OECD countries",
       subtitle = "Source: OCDE, 2019") +
  theme(panel.background = element_rect(fill = "grey97"),
        plot.background = element_rect(fill = "white"),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid = element_blank()) +
  guides(fill = guide_legend(title = "Number of\nthreatened\nspecies"))
```

Comme c'est le cas des points de la [figure @fig-spat_weather_ggmap1], on peut superposer des choroplèthes à des cartes téléchargées ([figure @fig-spat_choropleth_ggpmap1]).

```{r}
#| label: fig-spat_choropleth_ggpmap1
#| message: false
#| out-width: 100%
#| fig-align: center
#| fig-cap: "Nombre d'espèces en danger dans les pays de l'OCDE superposé à une carte importée par **`ggmap`**"

worldmap <- get_stadiamap(bbox = c(left=-170, right = 170, bottom = -80, top = 80),
                          zoom = 2,
                          maptype = "stamen_toner_lite")
world_iucn_oecd <- world_iucn %>% 
  filter(!is.na(n_threatened_species))
ggmap(worldmap,
      base_layer = ggplot(world_iucn_oecd, aes(long, lat))) +
  geom_polygon(aes(group = group, fill = n_threatened_species),
               colour = "black", lwd = 0.2) +
  coord_map(projection = "mercator", xlim = c(-180, 180), ylim = c(-90, 90)) +
  scale_fill_gradient(low = "blue", high = "red", na.value = "grey80") +
  labs(title = "Number of threatened species in OECD countries",
       subtitle = "Source: OCDE, 2019") +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.grid = element_blank()) +
  guides(fill = guide_legend(title = "Number of\nthreatened\nspecies"))
```

Si vous savez créer des polygones, vous saurez créer des lignes de manière similaire avec la couche graphique `geom_path()`. Pour les rasters, c'est moins évident.

## Les rasters

Les *rasters* sont des données associées à un grille. Nous avons introduit la fonction `expand.grid()` au [chapitre @sec-ia] lorsque nous désirions créer un tableau où chaque ligne désigne une des combinaisons possibles d'hyperparamètres pour ajuster un modèle d'autoapprentissage. De même, nous pouvons créer une grille comprenant les combinaisons de longitudes et de latitudes, puis créer une variable spatialisée $z = 10\times sin \left( xy \right) - 0.01x^2 + 0.05y^2$.

```{r}
#| label: spat-lonlat-grid

grid <- expand.grid(lon = seq(from = -80, to = -60, by = 0.25),
                    lat = seq(from = 45, to = 50, by = 0.25))
grid <- grid %>% 
  mutate(z = 10*sin(lon*lat) - 0.01*lon^2 + 0.05*lat^2) # créer une variable spatialisée

grid %>% head()
```

Pour visualiser une grille avec **`ggplot2`**, on peut avoir recourt à la couche graphique `geom_tile()`, dont la couleur remplissage est associée à la colonne `z` du tableau. Ce type de graphique est appelée *heatmap* ([figure @fig-spat-geom-tile]).

```{r}
#| label: fig-spat-geom-tile
#| out-width: 100%
#| fig-align: center
#| fig-cap: "Visualisation de la grille"

ggplot(grid, aes(lon, lat)) +
  geom_tile(aes(fill = z))
```

Remarquez que j'ai créé une fonction pour générer une variable spatialisée. *Une telle fonction n'a pas besoin d'être inventée*: on peut en créer une en utilisant les outils que nous avons appris jusqu'à présent, en particulier avec l'autoapprentissage.

## Autoapprentissage spatial

La géostatistique est l'étude statistique des variables spatiales, un sujet complexe qui sort du cadre de ce cours - que vous pourrez creuser dans le livre [*Applied Spatial Data Analysis with R*](https://asdar-book.org/). Ici, nous allons projeter des variables spatialisées à l'aide de l'autoapprentissage, où la position (coordonnées en longitude et latitude, par exemple) peut servir de variable prédictive (ainsi que, éventuellement, des variables spatialisées concernant l'altitude, l'hydrologie, la géomorphologie, l'écologie, la sociologie, la gestion du territoire, etc.). Pour ce faire, vous pourrez utiliser algorithme qui convient à vos données et à votre domaine d'étude. Nous allons utiliser les processus gaussiens, qui sont particulièrement utiles pour évaluer l'*incertitude* des prédictions. Par exemple, nous allons prédire sur une grille les données de degrés-jour du tableau `weather` avec un processus gaussien. Pour évaluer la *performance* d'une prédiction, n'oublions de séparer nos données en jeux d'entraînement et de test (avec la fonction `caret::createDataPartition()`)!

```{r}
#| label: spat-load-caret
#| message: false

library("caret")
weather_dd <- weather %>% 
  dplyr::select(lon, lat, degree_days) %>% 
  drop_na()
weather_dd_sc <- weather_dd %>% 
  mutate(degree_days = (degree_days - mean(degree_days))/sd(degree_days))
train_id <- createDataPartition(
  y = weather_dd_sc$degree_days,
  p = 0.7,
  list = FALSE
)[, 1]
```

Utilisons la fonction `kernlab::gausspr()`, vue au [chapitre @sec-ia].

```{r}
#| label: spat-model-kenlab
#| message: false

library("kernlab")
dd_gp <- gausspr(x = weather_dd_sc[train_id, c("lon", "lat")],
                 y = weather_dd_sc[train_id, "degree_days"],
                 kernel = "rbfdot",
                 #kpar = list(sigma = 01), # laisser optimiser
                 variance.model = TRUE,
                 scale = TRUE,
                 var = 0.1,
                 cross = 5)
```

Évaluons visuellement la performance de la prédiction ([figure @fig-spat_gp_perf]).

```{r}
#| label: fig-spat_gp_perf
#| out-width: 100%
#| fig-align: center
#| fig-cap: "Performance du processus gaussien en entraînement et en test."

pred_dd_tr <- predict(dd_gp)
pred_dd_te <- predict(dd_gp, newdata =  weather_dd_sc[-train_id, c("lon", "lat")])

par(mfrow = c(1, 2))
plot(weather_dd_sc$degree_days[train_id], pred_dd_tr, main = "Train prediction", xlab = "mesuré", ylab = "prédit")
abline(0, 1, col="red")
plot(weather_dd_sc$degree_days[-train_id], pred_dd_te, main = "Test prediction", xlab = "mesuré", ylab = "prédit")
abline(0, 1, col="red")
```

La prédiction n'est pas extraordinaire, mais gardons-la pour l'exemple (j'ai essayé avec des réseaux neuronaux sans plus de succès). La prochaine étape est de créer une grille où chaque point [longitude, latitude] servira de variable explicative pour calculer les degrés-jour.

```{r}
#| label: spat-grid-weather

grid <- expand.grid(lon = seq(from = -80, to = -60, by = 0.25),
                    lat = seq(from = 45, to = 50, by = 0.25))
grid <- grid %>% 
  mutate(pred_dd_mean = predict(dd_gp, newdata = ., type = "response") * sd(weather_dd$degree_days) + mean(weather_dd$degree_days),
         pred_dd_sd = predict(dd_gp, newdata = ., type = "sdeviation") * sd(weather_dd$degree_days))
head(grid)
```

Utilisons les polygones de la carte du monde zoomée à l'endroit qui nous intéresse, et ajoutons-y notre prédiction superposée par les localisations des stations météo. J'ajoute des contours ainsi que des étiquettes de contours (ce qui nécessite le module **`metR`**). Les processus gaussiens permettent de juxtaposer une carte des écart-type des prédictions, donnant une appréciation de la précision du modèle ([figure @fig-spat_pred_dd]). Cette juxtaposition est effectuée avec la fonction `plot_grid()` du module **`cowplot`**.

```{r}
#| label: fig-spat_pred_dd
#| warning: false
#| out-width: 100%
#| fig-align: center
#| fig-cap: "Prédiction des degrés-jour dans l'espace avec les processus gaussiens"
#| fig-width: 12

library("metR")
gg_mean <- ggplot(grid, aes(x = lon, y = lat)) +
  xlim(c(-80, -60)) +  ylim(c(45, 50)) +  coord_equal() +
  geom_tile(aes(fill = pred_dd_mean)) +
  geom_contour(data = grid, mapping = aes(x = lon, y = lat, z = pred_dd_mean), binwidth = 50, colour = "black", lwd = 0.2) +
  geom_label_contour(aes(z = pred_dd_mean)) +
  geom_path(data = world, aes(x = long, y = lat, group = group)) +
  geom_point(data = weather, mapping = aes(x = lon, y = lat), size = 0.1) +
  scale_fill_gradient(low = "#8CBFE6", high = "#FF0099", na.value = "grey80")

gg_sd <- ggplot(grid, aes(x = lon, y = lat)) +
  xlim(c(-80, -60)) +  ylim(c(45, 50)) +  coord_equal() +
  geom_tile(aes(fill = pred_dd_sd)) +
  geom_contour(data = grid, mapping = aes(x = lon, y = lat, z = pred_dd_sd), binwidth = 50, colour = "black", lwd = 0.2) +
  geom_label_contour(aes(z = pred_dd_sd)) +
  geom_path(data = world, aes(x = long, y = lat, group = group)) +
  geom_point(data = weather, mapping = aes(x = lon, y = lat), size = 0.1) +
  scale_fill_gradient(low = "#8CBFE6", high = "#FF0099", na.value = "grey80")

cowplot::plot_grid(gg_mean, gg_sd, labels = c("A", "B"), nrow = 2)
```

## Les objets spatialisés en R

Au [chapitre @sec-temps], nous avons couvert le type d'objet `ts`, spécialisé pour les séries temporelles. De même, le type d'objet `sf` est spécialisé pour les objets georéférencés. Les formats de données spatiales conventionnellement utilisés en R depuis 2003 sont offerts par le module **`sp`**. Ce format héritait de difficultés, récemment surmontées par le module [**`sf`**](https://r-spatial.github.io/sf/), plus convivial et mieux adapté au *tidyverse*. Bien que **`sp`** soit plus largement documenté, **`sf`** est suffisamment mature pour une utilisation professionnelle. Évidemment, [un aide-mémoire a été créé](https://github.com/rstudio/cheatsheets/raw/master/sf.pdf) ([figure @fig-sf_cheatsheet]).

```{r}
#| label: fig-sf_cheatsheet
#| out-width: 100%
#| fig-align: center
#| fig-cap: "[Aide-mémoire du module **`sf`**](https://github.com/rstudio/cheatsheets/raw/master/sf.pdf), créé par RStudio"
#| echo: false

knitr::include_graphics("images/12_sf-cheatsheet_canvas.png")
```

Nous avons couvert quatre types de données spatiales. Nous allons maintenant les traiter en deux catégories:

1. les données vectorielles, comprenant les points, lignes et polygones et
1. les données raster, comprenant les grilles de données.

### Données vectorielles (points, lignes et polygones)

Un cas typique consiste à importer un tableau de données localisées en un point, que l'on désire localiser en format `sf` avec la fonction `st_as_sf()`. Le tableau weather, par exemple, comporte une latitude (colonne `lat`) et une longitude (colonne `lon`), spécifiées dans l'argument `coord`. Puisqu'il s'agit de données canadiennes, je suppose que les coordonnées sont projetées en format NAD83, tel qu'utilisé par Statistique Canada et Ressources naturelles Canada (à défaut de trouver la bonne info en ce moment). Le code PROJ4, spécifié sous l'argument `crs`, décrit l'ellipsoïde utilisé pour calculer les longitudes et latitudes ainsi que, s'il y a lieu, la projection (détails plus loin dans la [section @sec-systeme-coord]).

```{r}
#| label: spat-load-sf

library("sf")
weather_geo <- weather %>% 
  st_as_sf(coords = c("lon", "lat"), crs = "+proj=longlat +datum=NAD83")
weather_geo
```

Notre objet `sf` comprend des métadonnées sur le type de géométrie (`geometry type: POINT`), les limites des objets (`bbox: ...`), le système de référence (`epsg` ou `proj4string: ...`) ainsi que le tableau descriptif. En format `sf`, la colonne `geometry` (qui elle est de type `sfc`) comprend dans chacune des cellules, exprimée sous forme de liste, toute l'information nécessaire à la construction de la géométrie, que ce soit un point, une ligne ou un polygone.

Pour ce qui est des polygones et des lignes, il est plus commun de les importer depuis des sources institutionnelles. On pourra télécharger des données géographiques, puis dézipper les fichier manuellement. Mais on peut aussi copier un lien, le coller dans R et dézipper automatiquement. Le block de code suivant télécharge un dossier de shapefiles décrivant les polygones des régions administratives du Québec.

```{r}
#| label: spat-download-shp
#| eval: false

download.file("ftp://ftp.mrnf.gouv.qc.ca/public/dgig/produits/bdga5m/vectoriel/region_admin_SHP.zip",
              destfile="data/12_quebec/12_region_admin_SHP.zip")
unzip("data/12_quebec/12_region_admin_SHP.zip", exdir = "data/12_quebec")
```

Pour charger dans R des shapefiles en format `sf`, nous utilisons la fonction `st_read()` pointant vers le fichier `.shp`.

```{r}
#| label: spat-load-shp

quebec <- st_read("data/12_quebec/region_admin_polygone.shp")
head(quebec)
```

Nous avons vu au [chapitre @sec-table] qu'il est préférable d'éviter la répétition de l'information. Dans le format `tibble` que nous avons utilisé pour décrire les polygones, l'information attachée à un polygone est répétée pour chaque point qui le compose: forcer une information hiérarchisée à se conformer à une structure rectangulaire multiplie la quantité d'information. Le format `sf` évite cette multiplication d'information en hiérarchisant les polygones dans la colonne `geometry`.

En guise d'exploration rapide, la fonction `plot()` affichera les choroplèthes.

```{r}
#| label: spat-quebec-plot
#| out-width: 100%
#| fig-align: center
#| fig-cap: " "

plot(quebec)
```

Si nous ne désirons que la géométrie,

```{r}
#| label: spat-quebec-geometry-plot
#| out-width: 100%
#| fig-align: center
#| fig-cap: " "

quebec %>%
  st_geometry() %>%
  plot() # ou bien plot(st_geometry(quebec)), ou bien plot(quebec %>% select(geometry))
```

**Exercice**. Explorer l'objet `quebec`, en particulier la colonne `geometry`, notamment en utilisant la fonction `str()`.

Vous pourrez soutirer les informations du système de coordonnées avec la fonction `st_crs()`. Il est possible de calculer des attributs des géométries à l'aide des fonctions `st_area()` pour les polygones, ou `st_length()` pour les lignes et les polygones et la fonction `st_centroid()` pour trouver le centroïde d'un polygone  - à cette étape, il se pourrait que R vous demande d'installer le module **`lwgeom`**: suivez ses consignes!

```{r}
#| label: spat-quebec-centroid-plot
#| fig-align: center
#| fig-cap: " "

quebec_point <- quebec %>% 
  mutate(st_area = st_area(quebec),
         st_length = st_length(quebec)) %>% 
  st_centroid()
plot(quebec_point)
```

Les aires et les périmètres calculés ne correspondent pas tout à fait à ceux des variables `AREA` et `PERIMETER`, probablement calculés sur une autre base. La fonction `st_centroid()` crée un nouveau tableau dont la géométrie est le `POINT`, elle doit donc être passée après les opérations sur les polygones.

La fonction `st_simplify()` permet de simplifier les polygones en un nombre réduit de points, ce qui peut être utile pour accélérer les calculs. La fonction `st_buffer()` permet de créer un rayon d'une longueur donnée autour d'un point, procédure souvent utilisée pour visualiser un rayon d'influence. Mais pour calculer des distances, les données doivent être projetées. Nous pouvons les projeter avec `st_transform()` avec [le code EPSG désiré](https://epsg.io/3348).

```{r}
#| label: spat-quebec-radius-plot
#| out-width: 100%
#| fig-align: center
#| fig-cap: " "

quebec_point %>% 
  st_transform(3348) %>% 
  st_buffer(50000) %>% # 50 km du centre de la région
  plot()
```

D'autres opérations sur les vecteurs sont offertes et documentées sous la fiche d'aire [`sf::geos_unary()`](https://r-spatial.github.io/sf/reference/geos_unary.html). 

Enfin, pour exporter un tableau `sf` en format csv *incluant la géométrie*, utilisez `st_write(obj = tableau, dsn = "tableau.csv", layer_options = "GEOMETRY=AS_XY")`.  Toutefois, si la géométrie n'est pas constituée de points, il faudra préalablement transformer les polygones en points avec `st_cast()`.

```{r}
#| label:  spat-st-write
#| eval: false

st_write(obj = quebec %>% 
           dplyr::filter(AREA < 1) %>% # ne retenir que quelques régions pour créer un fichier moins volumineux
           st_cast("POINT"),
         dsn = "data/12_quebec_export.csv",
         delete_dsn = TRUE,
         layer_options = "GEOMETRY=AS_XY")
```

### Données raster

Les données rasters sont des grilles, souvent enchâssées dans des images `tif` géoréférencées. Ces images peuvent comprendre plusieurs variables, que l'on nomme des *bandes*, en référence aux bandes spectrales des images satellitaires (rouge, vert et bleu). Les données raster peuvent être importées dans votre session grâce à la fonction du `rast()` du module **`terra`**.

::: {.callout-note}

Le module `terra` remplace l'ancien module `raster`, qui est toujours fonctionnel, mais `terra` a plus de fonctionnalités et est plus rapide.

:::

```{r}
#| label: spat-load-raster
#| message: false
#| warning: false

library("terra")

# Lecture d'un raster d'une bande
canopy <- rast("data/12_nytrees/canopy.tif") # source: https://assets.datacamp.com/production/repositories/738/datasets/79cb56df0fa27272e16b366a697aba8ac1d3e923/canopy.zip
canopy

# rast() permet aussi de lire des fichiers .tif contenant plus d'une bande
manhattan <- rast("data/12_nytrees/manhattan/manhattan.tif") # source: https://assets.datacamp.com/production/repositories/738/datasets/30830f8ba4a60aa1711f41e9a842b22cba3204f3/manhattan.zip
manhattan
```

La fonction `rast()` crée un objet de type `SpatRaster`, les informations de ces objets peuvent être extraites par les fonctions `ext()`, `ncell()`, `nlyr()` et `crs()`. La fonction `panel()` permet d'explorer les données en créant un graphique par bande.

```{r}
#| label: spat-manhattan-plot
#| out-width: 100%
#| fig-align: center
#| fig-cap: " "

terra::panel(manhattan)
```

Les fichiers raster, qui viennent souvent en format `tif`, sont typiquement très volumineux. Si une plus faible résolution convient à une analyse spatiale, on pourra simplifier un raster avec la fonction `terra::aggregate()` (j'utilise la notation `module::fonction()` pour éviter la confusion avec la fonction `dplyr::aggregate()`). L'argument `fact` est le facteur de conversion et l'argument `fun` est la fonction d’agrégation (typiquement `mean` ou `median`).

```{r}
#| label: spat-manhattan-lowres-plot
#| out-width: 100%
#| fig-align: center
#| fig-cap: " "

manhattan_lowres <- terra::aggregate(manhattan, fact = 20, fun = median)
manhattan_lowres

panel(manhattan_lowres)
```

Avec un facteur de conversion de 20, nous sommes passés d'une grille de 773 $\times$ 801 à 39 $\times$ 41. L'exemple utilisé est volontairement exagéré pour montrer l'effet de la perte de résolution, et généralement le facteur de conversion utilisé est plus faible que 20.

La fonction `classify()` est l'équivalent de `cut()` pour les rasters. L'argument demandé, en plus de l'objet raster, est une matrice de classification à trois colonnes. Les deux premières colonnes spécifient la plage de valeur à classifier et la troisième colonne spécifie la valeur de remplacement (qui peut être `NA`). La classification s'applique à toutes les couches s'il s'agit d'un `SpatRaster` avec plusieurs couches (bandes).

```{r}
#| label: spat-manhattan-rcl-plot
#| out-width: 100%
#| fig-align: center
#| fig-cap: " "

manhattan_rcl <- classify(manhattan_lowres,
                          rcl = matrix(c(0, 50, 1,
                                         50, 100, 2,
                                         100, 1000, NA)))
plot(manhattan_rcl)

```

## Les systèmes de coordonnées {#sec-systeme-coord}

Les longitudes et latitudes sont des angles sur un ellipsoïde de révolution. Différentes institutions utilisent différentes formes d'ellipsoïde portant leur nom particulier: NAD83, WGS84, ETRS89, etc. Les projections servent à aplanir des coordonnées géodésiques obtenues selon un ellipsoïde donné en vue de créer des représentations 2D, comme la projection Mercator universelle ou de [nombreuses autres](https://bl.ocks.org/mbostock/3711652). Le système de coordonnées peut être projeté ou non.

1. **Système de coordonnées *non*-projetées**: caractérisé par des angles de *longitude* et de *latitudes* sur un système géodésique 3D représenté par un ellipsoïde de révolution.
1. **Système de coordonnées projetées**: caractérisé par des distances X et Y sur une système géodésique représenté en 2D.

Lorsque vous utilisez des shapefiles, les informations du système de coordonnées seront incluses dans le fichier ayant une extension `prj`. Examinons le système de coordonnées du tableau `quebec` avec la fonction `st_crs()`.

```{r spat-st-crs}
st_crs(quebec)
```

D'emblée, la mention `+proj=longlat` retrouvée dans `proj4string` (une représentation de [PROJ4](https://proj4.org/)) indique que le système n'est pas projeté, et que le système géodésique est le [GRS80](https://en.wikipedia.org/wiki/Geodetic_Reference_System_1980), [pratiquement identique au WGS84](https://mern.gouv.qc.ca/territoire/outils/outils-faq.jsp). Le code `EPSG` contient la même information que le `proj4string`, traduite de manière succincte par un code à 4 chiffres. Dans certains cas, les informations du système de coordonnées ne sont pas disponibles: il vous faudra creuser si elles sont essentielles à vos travaux. Pour assigner un système de coordonnées, vous pourrez soit assigner l'EPSG par `st_crs(objet_sg) <- 4269` ou `objet_sg <- objet_sg %>% st_set_crs()`, ou bien le PROJ4 par `st_crs(objet_sg) <- "+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs"`. La procédure est la même pour les rasters, mais avec la fonction `crs()` au lieu de `st_crs()`.

Pour passer d'un système de coordonnées à un autre, utilisez `st_transform()` pour les vecteurs et `projectRasters()` pour les rasters. Pour les rasters, si vos données sont catégorielles, et non pas numérique, utilisez `method = "ngb"` plutôt que la valeur par défaut, `method = "bilinear"`, conçue pour les variables numériques.

## Manipuler des tableaux `sf`

Vous avez peut-être remarqué que j'ai précédemment effectué une opération `mutate()` en mode pipeline (`%>%`) sur un tableau `sf`. Eh oui, les `sf` sont compatibles avec le mode *tidyverse*. Vous pourrez filtrer avec `filter()`, sélectionner avec `select()` et manipuler des colonnes avec `mutate()`. Reprenons les données des espèces en danger, mais cette fois-ci nous allons travailler avec des données spatialisées avec `sf`. D'abord, allons chercher une carte du monde: le format geojson peut être importé de la même manière que des shapefiles. Puisqu'un geojson consigne l'information géographique en un seul fichier (les shapefiles en contiennent plusieurs), on peut l'importer directement d'Internet.

```{r}
#| label: spat-world-geojson
#| message: false

world_gj <- st_read("https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json")
world_gj
```

Des multipolygones sont formés lorsque plusieurs polygones forment une seule entité, par exemple un pays constitué de plusieurs îles. Nous allons effectuer la jointure entre le tableau `world_gj` et les données de l'IUCN. De même que précédemment, les noms des pays doivent correspondre exactement.

```{r}
#| label: spat-clean-iucn2

iucn_oecd <- iucn_oecd %>% 
  replace(.=="USA", "United States of America") %>% 
  replace(.=="UK", "United Kingdom") %>%
  replace(.=="Korea", "South Korea") %>%
  dplyr::rename("name" = "region")
```

Pour cette jointure, je désire ne conserver que les données géographiques des pays de l'OCDE. Je peux effectuer une jointure à gauche sur le tableau `iucn_oecd` ou une jointure à droite sur le tableau `world_gj`.

```{r}
#| label: spat-oecd-right-join

oecd_gj <- world_gj %>% 
  right_join(iucn_oecd, by = "name")
```

Contrairement aux tableaux `tibble`, le format `sf` conserve la géométrie.

```{r}
#| label: spat-iucn-select 

oecd_gj %>% 
  dplyr::select(name, n_threatened_species)
```

Pour une raison ou une autre, si vous désirez retirer la géométrie, 

```{r}
#| label: spat-iucn-top4

oecd_gj %>%
  dplyr::select(name, n_threatened_species) %>% 
  st_set_geometry(NULL) %>% 
  top_n(4)
```

On pourra explorer notre tableau avec la fonction `plot()`.

```{r}
#| label: spat-oecd_gj-plot
#| out-width: 100%
#| fig-align: center
#| fig-cap: " "

plot(oecd_gj)
```

Tout comme on effectue des jointures entre des tableaux, on peut effectuer des jointures spatiales sur des `sf`. On pourra trouver des intersections entre polygones, effectuer des unions, des différences, etc. Par exemple, en modélisation, il est commun d'extrapoler des résultats sur une grille. Ici, nous créons une grille couvrant tout le Québec ([figure @fig-spat_quebec_grid]).

1. Nous créons une grille constituée des centroïdes, `%>%` # (par défaut, il s'agit d'une grille de polygones rectangulaires)
1. nous transformons le résultat en format `sf` (au lieu de `sfc`), `%>%`
1. nous effectuons une jointure sous forme d'intersection et `%>%`
1. nous retirons les occurrences hors de la jointure.

```{r}
#| label: fig-spat_quebec_grid
#| out-width: 100%
#| fig-align: center
#| fig-cap: "Grilles de Québec et de la région de la Montérégie"

quebec_grid <- quebec %>% 
  st_make_grid(n = 80, what = "centers") %>% 
  st_sf() %>%  # transformer en objet sf
  st_join(quebec, join = st_intersects) %>% 
  drop_na()

par(mfrow = c(1, 2))
plot(quebec_grid %>% st_geometry(), pch = 16, cex = 0.2, main = "Grille Québec")
plot(quebec_grid %>% filter(RES_NM_REG == "Montérégie") %>% st_geometry(), main = "Grille Montérégie")
```

Pour soutirer la grille en vue de modéliser,

```{r}
#| label: spat-keep-qc-grid

quebec_grid %>%
  st_coordinates() %>% 
  as_tibble() %>% 
  dplyr::rename("lon" = "X", "lat" = "Y")
```

## Manipuler des objets raster

Comme les objets vectoriels, les objets raster peuvent subir différents types d'opérations. Nous en couvrirons trois.

- Masque (`mask()`): l'intersection entre un polygone et un raster.
- Découper (`crop()`): découpe rectangulaire selon les limites de l'objet.
- Extraction (`extract()`): extrait, et accessoirement effectue un sommaire, des rasters dans un polygone donné

Créons d'abord un polygone ayant le même système de coordonnées que le raster `canopy`.

```{r}
#| label: spat-poly-raster

poly <- st_sfc(st_polygon(list(cbind(c(1800000, 1830000, 1820000, 1800000),
                                     c(2160000, 2200000, 2150000, 2160000))))) %>%
  st_set_crs(st_crs(canopy)) %>%
  st_cast("POLYGON")
```

Pour pouvoir effectuer les différentes manipulations, il faut convertir l'objet `poly` au format `SpatVector`.

```{r}
#| label: spat-raster-sf-tp-sp

poly_vect = vect(poly)

```

Appliquons un masque, puis un crop, puis les deux.

```{r}
#| label: spat-raster-operations
#| fig-height: 3
#| fig-width: 12
#| out-width: 100%
#| fig-align: center
#| fig-cap: " "

canopy_mask <- mask(canopy, mask = poly_vect)
canopy_crop <- crop(canopy, y = poly_vect)
canopy_mc <- crop(canopy_mask, y = poly_vect)

par(mfrow = c(1, 4))
plot(canopy, main = "Original")
plot(poly_vect, add = TRUE)
plot(canopy_mask, main = "mask()")
plot(poly_vect, add = TRUE)
plot(canopy_crop, main = "crop()")
plot(poly_vect, add = TRUE)
plot(canopy_mc, main = "mask() & crop()")
plot(poly_vect, add = TRUE)
```

Pour effectuer un calcul sur l'intérieur du polygone avec `extract()`... on spécifie le raster, le polygone et la fonction!

```{r}
#| label: spat-extract-canopy

extract(canopy, poly_vect, fun = mean)
```

## Graphiques d'objets spatialisés

Pour afficher les objets `sf` et raster, nous avons utilisé les fonctions de base à titre exploratoire. Mais lorsque vient le temps de publier une carte, la trousse de **`ggplot2`** est toute indiquée, en y ajoutant l'outil `geom_sf()`.

```{r}
#| label: spat-quebec-sf-gg
#| out-width: 100%
#| fig-align: center
#| fig-cap: " "

ggplot(quebec) +
  geom_sf(aes(fill = RES_NM_REG)) +
  geom_sf(data = quebec_point)
```

Les coordonnées peuvent être manipulées avec `coord_sf()`.

```{r}
#| label: spat-iucn-north-america
#| out-width: 100%
#| fig-align: center
#| fig-cap: " "

world_gj_iucn <- world_gj %>%
  full_join(iucn_oecd, by = "name")

ggplot(world_gj_iucn) +
  geom_sf(aes(fill = n_threatened_species), colour = "gray50") +
  coord_sf(xlim = c(-170, -40), ylim = c(10, 80)) +
  scale_fill_gradient(low = "#8CBFE6", high = "#FF0099", na.value = "grey80") +
  labs(title = "Number of threatened species in OECD countries",
       subtitle = "Source: OCDE, 2019") +
  guides(fill = guide_legend(title = "Number of\nthreatened\nspecies"))
```

Les cartes thématiques de [`tmap`](https://www.jstatsoft.org/article/view/v084i06) (*thematic maps*) sont construites sensiblement de la même manière que **`ggplot2`**. Différents types de projections sont [disponibles](https://www.rdocumentation.org/packages/tmaptools/versions/2.0-1/topics/get_proj4) avec différentes palettes de couleurs (`palette_explorer()`).

```{r}
world_gj_iucn <- world_gj_iucn %>% 
  filter(!is.na(id))
```


```{r spat-iucn-tmap, out.width="100%", fig.align="center", fig.cap=" "}
#| label: spat-iucn-tmap
#| out-width: 100%
#| fig-align: center
#| fig-cap: " "

library("tmap")
library("tmaptools")
tm_shape(set_projection(world_gj_iucn, 4326)) +
  tm_polygons("n_threatened_species", palette = "viridis")
```

Si vous désirez créer des cartes interactives, passez en mode [*leaflet*](https://rstudio.github.io/leaflet/) en spécifiant `tmap_mode("view")` (pour revenir en mode statique, `tmap_mode("plot")`)

```{r}
#| label: spat-iucn-tmap-view
#| out-width: 100%
#| fig-align: center
#| fig-cap: " "

tmap_mode("view")
tm_shape(world_gj_iucn) +
  tm_polygons("n_threatened_species", palette = "viridis")
```

Petit exemple avec des facettes synchronisées.

```{r}
#| label: spat-quebec-tmap-facet
#| out-width: 100%
#| fig-align: center
#| fig-cap: " "

quebec_tmap <- tm_shape(quebec) +
  tm_polygons(c("AREA", "PERIMETER")) +
  tm_facets(sync = TRUE, ncol = 2)
quebec_tmap
```

Les cartes `tmap` peuvent être exportées sous forme d'image.

```{r}
#| label: spat-tmap-save

tmap_save(tm = quebec_tmap, filename = "images/12_quebec_tmap.png", height=7)
```

Toutefois, au moment d'écrire ces lignes, l'exportation en format dynamique [ne fonctionne pas pour les facettes](https://github.com/r-spatial/mapview/issues/35). De plus, il semble y avoir [un bogue avec les chemins relatifs](https://stackoverflow.com/a/48691210). Il faudra donc coller (`paste0`) le répertoire de travail (`getwd()`) au chemin relatif (`"/images/12_quebec_tmap_widget/12_quebec_tmap.html"`). Enfin, les fichiers html font souvent référence à des fichiers externes: mieux vaut les enregistrer dans des dossiers indépendants (dans ce cas dans `"12_quebec_tmap_widget"`, que vous pourrez zipper avant de partager, ou placer sur un site web) plutôt que dans un dossier comprenant plusieurs images. Pas si compliqué... quand on le sait.

```{r}
#| label: spat-tmap-html

quebec_tmap_area <- tm_shape(quebec) +
  tm_polygons("AREA")
tmap_save(tm = quebec_tmap_area, filename = paste0(getwd(),"/images/12_quebec_tmap_widget/12_quebec_tmap.html"))
```

## Ressources complémentaires

- [Geocomputation with R](https://r.geocompx.org/), de Robin Lovelace, Jakub Nowosad et Jannes Muenchow (2024).
- [Spatial Data Science](https://www.rspatial.org/), de Robert J. Hijmans, du Geospatial and Farming Systems Research Consortium (GFC), University of California (2019)
- [Spatial data science - with applications in R](https://r-spatial.org/book/), de Edzer Pebesma et Roger Bivand (2023). 
- [Simple Features for R](https://r-spatial.github.io/sf/index.html), de Edzer Pebesma et 
Roger Bivand (2023).

```{r spat-rm, include=FALSE}
rm(list = ls())
```
